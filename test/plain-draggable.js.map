{"version":3,"sources":["webpack://PlainDraggable/webpack/bootstrap","webpack://PlainDraggable/./node_modules/anim-event/anim-event.esm.js","webpack://PlainDraggable/./node_modules/cssprefix/cssprefix.esm.js","webpack://PlainDraggable/./node_modules/m-class-list/m-class-list.esm.js","webpack://PlainDraggable/./src/plain-draggable.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA,aAAa,OAAO;AACpB,cAAc,MAAM;AACpB,cAAc,SAAS;AACvB;;AAEA,WAAW,OAAO;AAClB;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0E;;;;;;;;;;;;AC5GA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;;AAGD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA,YAAY;AACZ,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ,CAAC;;;AAGD;AACA;AACA,YAAY;AACZ,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE;AACT;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,iBAAiB;AACjB,GAAG;;AAEH,gDAAgD;AAChD;;AAEA;AACA;AACA;AACA;;AAEA,0E;;;;;;;;;;;;ACnLA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA,2E;;;;;;;;;;;;;;;AC9GA;AAAA,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,oGAAoG,mBAAmB,EAAE,mBAAmB,8HAA8H;;AAE1Q,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;;AAGD,WAAW,4BAA4B;AACvC,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,eAAe;AACf;;;AAGA,cAAc,kBAAkB;AAChC,uBAAuB,yBAAyB;AAChD,wBAAwB;AACxB,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,4BAA4B;AAC1C,aAAa,SAAS;AACtB,eAAe;AACf;;;AAGA;AACA,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;;AAEA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;;AAEP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA,aAAa,OAAO;AACpB,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA,cAAc,iCAAiC;AAC/C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kEAAkE,qFAAqF,QAAQ;AAC/J;;AAEA,4BAA4B,+BAA+B;AAC3D;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA,iDAAiD;;AAEjD;AACA;AACA,mBAAmB;AACnB,gDAAgD;AAChD,sBAAsB,oCAAoC;AAC1D,oBAAoB;AACpB;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA,qCAAqC;;AAErC;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,KAAK;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,YAAY,2BAA2B;AACvC,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY,2BAA2B;AACvC,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY,2BAA2B;AACvC,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,YAAY,2BAA2B;AACvC,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA,mCAAmC;AACnC,4DAA4D;AAC5D;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mCAAmC,+EAA+E;;AAElH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+EAA+E;;AAElH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA8B,mEAAmE;;;AAGjG;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAA+C;;AAE9D;;AAEA;;AAEA;AACA,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;;AAEA;AACA,yBAAyB,8CAA8C;AACvE,iBAAiB,oCAAoC;AACrD,iBAAiB,oCAAoC;AACrD,qBAAqB;AACrB,sFAAsF;AACtF;AACA;AACA,0BAA0B,oCAAoC;AAC9D,wBAAwB;;AAExB;AACA;AACA,oBAAoB,kEAAkE;AACtF,oBAAoB,SAAS;AAC7B,oBAAoB,SAAS;AAC7B,oBAAoB,QAAQ;AAC5B,oBAAoB,OAAO;AAC3B,oBAAoB,OAAO;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2IAA2I;AAC3I;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wEAAwE,EAAE;AACrG,2BAA2B,yEAAyE,EAAE;AACtG;AACA,2BAA2B,2EAA2E,EAAE;AACxG,2BAA2B,0EAA0E,EAAE;AACvG,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC;AACpC,sEAAsE;AACtE,+CAA+C;;AAE/C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8DAA8D,QAAQ;AACtE;AACA;AACA;AACA;AACA,sBAAsB;AACtB,0DAA0D;AAC1D;AACA,sBAAsB;AACtB,2EAA2E;AAC3E;;AAEA,wCAAwC;AACxC;AACA,KAAK;AACL;AACA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,YAAY,kBAAkB;AAC9B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,eAAe,OAAO;AACtB,gBAAgB,oBAAoB;AACpC,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;;AAEA;AACA,eAAe,OAAO;AACtB,gBAAgB,gBAAgB,0BAA0B,WAAW,IAAI;AACzE,gBAAgB,gBAAgB;AAChC,gBAAgB,iBAAiB;AACjC,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;;AAEA;AACA,eAAe,OAAO;AACtB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ,qBAAqB,WAAW,IAAI,iBAAiB;AAC7E,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ,oBAAoB,iBAAiB;AAC7D,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,SAAS;AACzB,gBAAgB,SAAS;AACzB,gBAAgB,QAAQ;AACxB,gBAAgB,SAAS;AACzB,gBAAgB,OAAO;AACvB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;;AAE/C;AACA;AACA,2GAA2G,2BAA2B;AACtI;AACA,yCAAyC,8BAA8B;;AAEvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0DAA0D,sBAAsB;AAChF;AACA,OAAO,uBAAuB;AAC9B,kCAAkC;AAClC;AACA,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA,wCAAwC,0BAA0B;AAClE;AACA,OAAO;AACP;AACA,wCAAwC,iBAAiB;AACzD;AACA,OAAO;AACP,6BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,gBAAgB,WAAW,IAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,mDAAmD;AACnD,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,mEAAmE;AAC7G,WAAW,iEAAiE;AAC5E,WAAW,mEAAmE;AAC9E,WAAW;AACX,WAAW;AACX,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;;AAEA;AACA,eAAe,OAAO;AACtB,gBAAgB,iBAAiB;AACjC,gBAAgB,MAAM;AACtB,gBAAgB,MAAM;AACtB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;;AAEA;AACA;AACA,0FAA0F,0EAA0E;AACpK;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA,OAAO;AACP;AACA;;AAEA,wCAAwC,iBAAiB;AACzD;AACA;AACA,gEAAgE;;AAEhE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,eAAe,eAAe;AAC9B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA,uCAAuC,cAAc;AACrD;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA,uCAAuC,aAAa;AACpD;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,uCAAuC,qBAAqB;AAC5D;;AAEA;;AAEA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA,uCAAuC,cAAc;AACrD;AACA;;AAEA;;AAEA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA,uCAAuC,oBAAoB;AAC3D;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA,uCAAuC,gBAAgB;AACvD;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA,uCAAuC,gBAAgB;AACvD;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA,uCAAuC,gBAAgB;AACvD;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA,uCAAuC,gBAAgB;AACvD;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA,uCAAuC,qBAAqB;AAC5D;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA,uCAAuC,mBAAmB;AAC1D;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;;;AAGA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAsC;AACrD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,qDAAqD;AACrD,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,+E","file":"plain-draggable.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/plain-draggable.js\");\n","/* ================================================\n        DON'T MANUALLY EDIT THIS FILE\n================================================ */\n\n/*\n * AnimEvent\n * https://github.com/anseki/anim-event\n *\n * Copyright (c) 2018 anseki\n * Licensed under the MIT license.\n */\n\nvar MSPF = 1000 / 60,\n    // ms/frame (FPS: 60)\nKEEP_LOOP = 500,\n\n\n/**\n * @typedef {Object} task\n * @property {Event} event\n * @property {function} listener\n */\n\n/** @type {task[]} */\ntasks = [];\n\nvar requestAnim = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n  return setTimeout(callback, MSPF);\n},\n    cancelAnim = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || function (requestID) {\n  return clearTimeout(requestID);\n};\n\nvar lastFrameTime = Date.now(),\n    requestID = void 0;\n\nfunction step() {\n  var called = void 0,\n      next = void 0;\n\n  if (requestID) {\n    cancelAnim.call(window, requestID);\n    requestID = null;\n  }\n\n  tasks.forEach(function (task) {\n    var event = void 0;\n    if (event = task.event) {\n      task.event = null; // Clear it before `task.listener()` because that might fire another event.\n      task.listener(event);\n      called = true;\n    }\n  });\n\n  if (called) {\n    lastFrameTime = Date.now();\n    next = true;\n  } else if (Date.now() - lastFrameTime < KEEP_LOOP) {\n    // Go on for a while\n    next = true;\n  }\n  if (next) {\n    requestID = requestAnim.call(window, step);\n  }\n}\n\nfunction indexOfTasks(listener) {\n  var index = -1;\n  tasks.some(function (task, i) {\n    if (task.listener === listener) {\n      index = i;\n      return true;\n    }\n    return false;\n  });\n  return index;\n}\n\nvar AnimEvent = {\n  /**\n   * @param {function} listener - An event listener.\n   * @returns {(function|null)} A wrapped event listener.\n   */\n  add: function add(listener) {\n    var task = void 0;\n    if (indexOfTasks(listener) === -1) {\n      tasks.push(task = { listener: listener });\n      return function (event) {\n        task.event = event;\n        if (!requestID) {\n          step();\n        }\n      };\n    }\n    return null;\n  },\n  remove: function remove(listener) {\n    var iRemove = void 0;\n    if ((iRemove = indexOfTasks(listener)) > -1) {\n      tasks.splice(iRemove, 1);\n      if (!tasks.length && requestID) {\n        cancelAnim.call(window, requestID);\n        requestID = null;\n      }\n    }\n  }\n};\n\nexport default AnimEvent;","/* ================================================\n        DON'T MANUALLY EDIT THIS FILE\n================================================ */\n\n/*\n * CSSPrefix\n * https://github.com/anseki/cssprefix\n *\n * Copyright (c) 2018 anseki\n * Licensed under the MIT license.\n */\n\nfunction ucf(text) {\n  return text.substr(0, 1).toUpperCase() + text.substr(1);\n}\n\nvar PREFIXES = ['webkit', 'moz', 'ms', 'o'],\n    NAME_PREFIXES = PREFIXES.reduce(function (prefixes, prefix) {\n  prefixes.push(prefix);\n  prefixes.push(ucf(prefix));\n  return prefixes;\n}, []),\n    VALUE_PREFIXES = PREFIXES.map(function (prefix) {\n  return '-' + prefix + '-';\n}),\n\n\n/**\n * Get sample CSSStyleDeclaration.\n * @returns {CSSStyleDeclaration}\n */\ngetDeclaration = function () {\n  var declaration = void 0;\n  return function () {\n    return declaration = declaration || document.createElement('div').style;\n  };\n}(),\n\n\n/**\n * Normalize name.\n * @param {} propName - A name that is normalized.\n * @returns {string} A normalized name.\n */\nnormalizeName = function () {\n  var rePrefixedName = new RegExp('^(?:' + PREFIXES.join('|') + ')(.)', 'i'),\n      reUc = /[A-Z]/;\n  return function (propName) {\n    return (propName = (propName + '').replace(/\\s/g, '').replace(/-([\\da-z])/gi, function (str, p1) {\n      return p1.toUpperCase();\n    }) // camelCase\n    // 'ms' and 'Ms' are found by rePrefixedName 'i' option\n    .replace(rePrefixedName, function (str, p1) {\n      return reUc.test(p1) ? p1.toLowerCase() : str;\n    }) // Remove prefix\n    ).toLowerCase() === 'float' ? 'cssFloat' : propName;\n  }; // For old CSSOM\n}(),\n\n\n/**\n * Normalize value.\n * @param {} propValue - A value that is normalized.\n * @returns {string} A normalized value.\n */\nnormalizeValue = function () {\n  var rePrefixedValue = new RegExp('^(?:' + VALUE_PREFIXES.join('|') + ')', 'i');\n  return function (propValue) {\n    return (propValue != null ? propValue + '' : '').replace(/\\s/g, '').replace(rePrefixedValue, '');\n  };\n}(),\n\n\n/**\n * Polyfill for `CSS.supports`.\n * @param {string} propName - A name.\n * @param {string} propValue - A value.\n *     Since `CSSStyleDeclaration.setProperty` might return unexpected result,\n *     the `propValue` should be checked before the `cssSupports` is called.\n * @returns {boolean} `true` if given pair is accepted.\n */\ncssSupports = function () {\n  return (\n    // return window.CSS && window.CSS.supports || ((propName, propValue) => {\n    // `CSS.supports` doesn't find prefixed property.\n    function (propName, propValue) {\n      var declaration = getDeclaration();\n      // In some browsers, `declaration[prop] = value` updates any property.\n      propName = propName.replace(/[A-Z]/g, function (str) {\n        return '-' + str.toLowerCase();\n      }); // kebab-case\n      declaration.setProperty(propName, propValue);\n      return declaration[propName] != null && // Because getPropertyValue returns '' if it is unsupported\n      declaration.getPropertyValue(propName) === propValue;\n    }\n  );\n}(),\n\n\n// Cache\npropNames = {},\n    propValues = {};\n\nfunction getName(propName) {\n  propName = normalizeName(propName);\n  if (propName && propNames[propName] == null) {\n    var declaration = getDeclaration();\n\n    if (declaration[propName] != null) {\n      // Original\n      propNames[propName] = propName;\n    } else {\n      // Try with prefixes\n      var ucfName = ucf(propName);\n      if (!NAME_PREFIXES.some(function (prefix) {\n        var prefixed = prefix + ucfName;\n        if (declaration[prefixed] != null) {\n          propNames[propName] = prefixed;\n          return true;\n        }\n        return false;\n      })) {\n        propNames[propName] = false;\n      }\n    }\n  }\n  return propNames[propName] || void 0;\n}\n\nfunction getValue(propName, propValue) {\n  var res = void 0;\n\n  if (!(propName = getName(propName))) {\n    return res;\n  } // Invalid property\n\n  propValues[propName] = propValues[propName] || {};\n  (Array.isArray(propValue) ? propValue : [propValue]).some(function (propValue) {\n    propValue = normalizeValue(propValue);\n\n    if (propValues[propName][propValue] != null) {\n      // Cache\n      if (propValues[propName][propValue] !== false) {\n        res = propValues[propName][propValue];\n        return true;\n      }\n      return false; // Continue to next value\n    }\n\n    if (cssSupports(propName, propValue)) {\n      // Original\n      res = propValues[propName][propValue] = propValue;\n      return true;\n    }\n\n    if (VALUE_PREFIXES.some(function (prefix) {\n      // Try with prefixes\n      var prefixed = prefix + propValue;\n      if (cssSupports(propName, prefixed)) {\n        res = propValues[propName][propValue] = prefixed;\n        return true;\n      }\n      return false;\n    })) {\n      return true;\n    }\n\n    propValues[propName][propValue] = false;\n    return false; // Continue to next value\n  });\n\n  return typeof res === 'string' ? res : void 0; // It might be empty string.\n}\n\nvar CSSPrefix = {\n  getName: getName,\n  getValue: getValue\n};\n\nexport default CSSPrefix;","/* ================================================\n        DON'T MANUALLY EDIT THIS FILE\n================================================ */\n\n/*\n * mClassList\n * https://github.com/anseki/m-class-list\n *\n * Copyright (c) 2018 anseki\n * Licensed under the MIT license.\n */\n\nfunction normalize(token) {\n  return (token + '').trim();\n} // Not `||`\nfunction applyList(list, element) {\n  element.setAttribute('class', list.join(' '));\n}\n\nfunction _add(list, element, tokens) {\n  if (tokens.filter(function (token) {\n    if (!(token = normalize(token)) || list.indexOf(token) !== -1) {\n      return false;\n    }\n    list.push(token);\n    return true;\n  }).length) {\n    applyList(list, element);\n  }\n}\n\nfunction _remove(list, element, tokens) {\n  if (tokens.filter(function (token) {\n    var i = void 0;\n    if (!(token = normalize(token)) || (i = list.indexOf(token)) === -1) {\n      return false;\n    }\n    list.splice(i, 1);\n    return true;\n  }).length) {\n    applyList(list, element);\n  }\n}\n\nfunction _toggle(list, element, token, force) {\n  var i = list.indexOf(token = normalize(token));\n  if (i !== -1) {\n    if (force) {\n      return true;\n    }\n    list.splice(i, 1);\n    applyList(list, element);\n    return false;\n  }\n  if (force === false) {\n    return false;\n  }\n  list.push(token);\n  applyList(list, element);\n  return true;\n}\n\nfunction _replace(list, element, token, newToken) {\n  var i = void 0;\n  if (!(token = normalize(token)) || !(newToken = normalize(newToken)) || token === newToken || (i = list.indexOf(token)) === -1) {\n    return;\n  }\n  list.splice(i, 1);\n  if (list.indexOf(newToken) === -1) {\n    list.push(newToken);\n  }\n  applyList(list, element);\n}\n\nfunction mClassList(element) {\n  return !mClassList.ignoreNative && element.classList || function () {\n    var list = (element.getAttribute('class') || '').trim().split(/\\s+/).filter(function (token) {\n      return !!token;\n    }),\n        ins = {\n      length: list.length,\n      item: function item(i) {\n        return list[i];\n      },\n      contains: function contains(token) {\n        return list.indexOf(normalize(token)) !== -1;\n      },\n      add: function add() {\n        _add(list, element, Array.prototype.slice.call(arguments));\n        return mClassList.methodChain ? ins : void 0;\n      },\n      remove: function remove() {\n        _remove(list, element, Array.prototype.slice.call(arguments));\n        return mClassList.methodChain ? ins : void 0;\n      },\n\n      toggle: function toggle(token, force) {\n        return _toggle(list, element, token, force);\n      },\n      replace: function replace(token, newToken) {\n        _replace(list, element, token, newToken);\n        return mClassList.methodChain ? ins : void 0;\n      }\n    };\n    return ins;\n  }();\n}\n\nmClassList.methodChain = true;\n\nexport default mClassList;","var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\n * PlainDraggable\n * https://anseki.github.io/plain-draggable/\n *\n * Copyright (c) 2018 anseki\n * Licensed under the MIT license.\n */\n\nimport CSSPrefix from 'cssprefix';\nimport AnimEvent from 'anim-event';\nimport mClassList from 'm-class-list';\nmClassList.ignoreNative = true;\n\nvar ZINDEX = 9000,\n\n// [SNAP]\nSNAP_GRAVITY = 20,\n    SNAP_CORNER = 'tl',\n    SNAP_SIDE = 'both',\n    SNAP_EDGE = 'both',\n    SNAP_BASE = 'containment',\n    SNAP_ALL_CORNERS = ['tl', 'tr', 'bl', 'br'],\n    SNAP_ALL_SIDES = ['start', 'end'],\n    SNAP_ALL_EDGES = ['inside', 'outside'],\n\n// [/SNAP]\n\n// [AUTO-SCROLL]\nAUTOSCROLL_SPEED = [40, 200, 1000],\n    AUTOSCROLL_SENSITIVITY = [120, 40, 0],\n\n// [/AUTO-SCROLL]\n\nIS_WEBKIT = !window.chrome && 'WebkitAppearance' in document.documentElement.style,\n    IS_GECKO = 'MozAppearance' in document.documentElement.style,\n    // [SVG/]\n\nisObject = function () {\n  var toString = {}.toString,\n      fnToString = {}.hasOwnProperty.toString,\n      objFnString = fnToString.call(Object);\n  return function (obj) {\n    var proto = void 0,\n        constr = void 0;\n    return obj && toString.call(obj) === '[object Object]' && (!(proto = Object.getPrototypeOf(obj)) || (constr = proto.hasOwnProperty('constructor') && proto.constructor) && typeof constr === 'function' && fnToString.call(constr) === objFnString);\n  };\n}(),\n    isFinite = Number.isFinite || function (value) {\n  return typeof value === 'number' && window.isFinite(value);\n},\n\n\n/** @type {Object.<_id: number, props>} */\ninsProps = {},\n    pointerOffset = {};\n\nvar insId = 0,\n    activeItem = void 0,\n    hasMoved = void 0,\n    body = void 0,\n\n// CSS property/value\ncssValueDraggableCursor = void 0,\n    cssValueDraggingCursor = void 0,\n    cssOrgValueBodyCursor = void 0,\n    cssPropTransitionProperty = void 0,\n    cssPropTransform = void 0,\n    cssPropUserSelect = void 0,\n    cssOrgValueBodyUserSelect = void 0,\n\n// Try to set `cursor` property.\ncssWantedValueDraggableCursor = IS_WEBKIT ? ['all-scroll', 'move'] : ['grab', 'all-scroll', 'move'],\n    cssWantedValueDraggingCursor = IS_WEBKIT ? 'move' : ['grabbing', 'move'],\n\n// class\ndraggableClass = 'plain-draggable',\n    draggingClass = 'plain-draggable-dragging',\n    movingClass = 'plain-draggable-moving';\n\n// Event Controller for mouse and touch interfaces\nvar pointerEvent = {};\n{\n\n  // Gecko, Trident pick drag-event of some elements such as img, a, etc.\n  var dragstart = function dragstart(event) {\n    event.preventDefault();\n  };\n\n  /**\n   * @param {Element} element - A target element.\n   * @param {number} handlerId - An ID which was returned by regStartHandler.\n   * @returns {void}\n   */\n\n\n  /** @type {{clientX, clientY}} */\n  var lastPointerXY = { clientX: 0, clientY: 0 },\n      startHandlers = {},\n      DUPLICATE_INTERVAL = 400; // For avoiding mouse event that fired by touch interface\n  var handlerId = 0,\n      lastStartTime = 0,\n      curPointerClass = void 0,\n      curMoveHandler = void 0;\n\n  /**\n   * @param {function} startHandler - This is called with pointerXY when it starts. This returns boolean.\n   * @returns {number} handlerId which is used for adding/removing to element.\n   */\n  pointerEvent.regStartHandler = function (startHandler) {\n    startHandlers[++handlerId] = function (event) {\n      var pointerClass = event.type === 'mousedown' ? 'mouse' : 'touch',\n          pointerXY = pointerClass === 'mouse' ? event : event.targetTouches[0] || event.touches[0],\n          now = Date.now();\n      if (curPointerClass && pointerClass !== curPointerClass && now - lastStartTime < DUPLICATE_INTERVAL) {\n        console.log('Event \"' + event.type + '\" was ignored.'); // [DEBUG/]\n        return;\n      }\n      if (startHandler(pointerXY)) {\n        curPointerClass = pointerClass;\n        lastPointerXY.clientX = pointerXY.clientX;\n        lastPointerXY.clientY = pointerXY.clientY;\n        lastStartTime = now;\n        event.preventDefault();\n      }\n    };\n    return handlerId;\n  };pointerEvent.addStartHandler = function (element, handlerId) {\n    element.addEventListener('mousedown', startHandlers[handlerId], false);\n    element.addEventListener('touchstart', startHandlers[handlerId], false);\n    element.addEventListener('dragstart', dragstart, false);\n  };\n\n  /**\n   * @param {Element} element - A target element.\n   * @param {number} handlerId - An ID which was returned by regStartHandler.\n   * @returns {void}\n   */\n  pointerEvent.removeStartHandler = function (element, handlerId) {\n    element.removeEventListener('mousedown', startHandlers[handlerId], false);\n    element.removeEventListener('touchstart', startHandlers[handlerId], false);\n    element.removeEventListener('dragstart', dragstart, false);\n  };\n\n  /**\n   * @param {Element} element - A target element.\n   * @param {function} moveHandler - This is called with pointerXY when it moves.\n   * @returns {void}\n   */\n  pointerEvent.addMoveHandler = function (element, moveHandler) {\n    var pointerMove = AnimEvent.add(function (event) {\n      var pointerClass = event.type === 'mousemove' ? 'mouse' : 'touch',\n          pointerXY = pointerClass === 'mouse' ? event : event.targetTouches[0] || event.touches[0];\n      if (pointerClass === curPointerClass) {\n        moveHandler(pointerXY);\n        lastPointerXY.clientX = pointerXY.clientX;\n        lastPointerXY.clientY = pointerXY.clientY;\n        event.preventDefault();\n      }\n    });\n    element.addEventListener('mousemove', pointerMove, false);\n    element.addEventListener('touchmove', pointerMove, false);\n    curMoveHandler = moveHandler;\n  };\n\n  /**\n   * @param {Element} element - A target element.\n   * @param {function} endHandler - This is called when it ends.\n   * @returns {void}\n   */\n  pointerEvent.addEndHandler = function (element, endHandler) {\n    function pointerEnd(event) {\n      var pointerClass = event.type === 'mouseup' ? 'mouse' : 'touch';\n      if (pointerClass === curPointerClass) {\n        endHandler();\n        curPointerClass = null;\n        event.preventDefault();\n      }\n    }\n    element.addEventListener('mouseup', pointerEnd, false);\n    element.addEventListener('touchend', pointerEnd, false);\n    element.addEventListener('touchcancel', pointerEnd, false);\n  };\n\n  pointerEvent.callMoveHandler = function () {\n    if (curMoveHandler) {\n      curMoveHandler(lastPointerXY);\n    }\n  };\n}\n\n// [AUTO-SCROLL]\n// Scroll Animation Controller\nvar scrollFrame = {},\n    MSPF = 1000 / 60,\n    // ms/frame (FPS: 60)\nrequestAnim = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n  return setTimeout(callback, MSPF);\n},\n    cancelAnim = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || function (requestID) {\n  return clearTimeout(requestID);\n};\n{\n  var frameUpdate = function frameUpdate() {\n    var now = Date.now();\n    ['x', 'y'].forEach(function (xy) {\n      var moveArgs = curXyMoveArgs[xy];\n      if (moveArgs) {\n        var timeLen = now - moveArgs.lastFrameTime,\n            absValue = curScrollXY(curElement, xy),\n            curValue = moveArgs.lastValue != null && Math.abs(moveArgs.lastValue - absValue) < 10 // It was not moved manually\n        ? moveArgs.lastValue : absValue;\n        if (moveArgs.dir === -1 ? curValue > moveArgs.min : curValue < moveArgs.max) {\n          var newValue = curValue + moveArgs.speed * timeLen * moveArgs.dir;\n          if (newValue < moveArgs.min) {\n            newValue = moveArgs.min;\n          } else if (newValue > moveArgs.max) {\n            newValue = moveArgs.max;\n          }\n          curScrollXY(curElement, xy, newValue);\n          moveArgs.lastValue = newValue;\n        }\n        moveArgs.lastFrameTime = now;\n      }\n    });\n  };\n\n  var frame = function frame() {\n    cancelAnim.call(window, requestID);\n    frameUpdate();\n    requestID = requestAnim.call(window, frame);\n  };\n\n  /**\n   * @param {Element} element - A target element.\n   * @param {{x: ?MoveArgs, y: ?MoveArgs}} xyMoveArgs - MoveArgs for x and y\n   * @param {function} scrollXY - (element: Element, xy: string, value: number) => number\n   * @returns {void}\n   */\n\n\n  /**\n   * @typedef {Object} MoveArgs\n   * @property {number} dir - [-1 | 1] minus or plus to position value.\n   * @property {number} speed - px/ms\n   * @property {number} min - Minimum position value.\n   * @property {number} max - Maximum position value.\n   * @property {number} [lastFrameTime] - Time of last frame.\n   * @property {number} [lastValue] - Strict value of last frame.\n   */\n\n  var curXyMoveArgs = {},\n      curElement = void 0,\n      curScrollXY = void 0,\n      requestID = void 0;\n\n  scrollFrame.move = function (element, xyMoveArgs, scrollXY) {\n    cancelAnim.call(window, requestID);\n    frameUpdate(); // Update current data now because it might be not continuation.\n\n    // Re-use lastValue\n    if (curElement === element) {\n      if (xyMoveArgs.x && curXyMoveArgs.x) {\n        xyMoveArgs.x.lastValue = curXyMoveArgs.x.lastValue;\n      }\n      if (xyMoveArgs.y && curXyMoveArgs.y) {\n        xyMoveArgs.y.lastValue = curXyMoveArgs.y.lastValue;\n      }\n    }\n\n    curElement = element;\n    curXyMoveArgs = xyMoveArgs;\n    curScrollXY = scrollXY;\n\n    var now = Date.now();\n    ['x', 'y'].forEach(function (xy) {\n      var moveArgs = curXyMoveArgs[xy];\n      if (moveArgs) {\n        moveArgs.lastFrameTime = now;\n      }\n    });\n\n    requestID = requestAnim.call(window, frame);\n  };\n\n  scrollFrame.stop = function () {\n    cancelAnim.call(window, requestID);\n    frameUpdate();\n    curXyMoveArgs = {};\n    curElement = null; // Remove reference\n  };\n}\n\nfunction scrollXYWindow(element, xy, value) {\n  if (value != null) {\n    if (xy === 'x') {\n      element.scrollTo(value, element.pageYOffset);\n    } else {\n      element.scrollTo(element.pageXOffset, value);\n    }\n  }\n  return xy === 'x' ? element.pageXOffset : element.pageYOffset;\n}\n\nfunction scrollXYElement(element, xy, value) {\n  var prop = xy === 'x' ? 'scrollLeft' : 'scrollTop';\n  if (value != null) {\n    element[prop] = value;\n  }\n  return element[prop];\n}\n\n/**\n * @typedef {Object} Scrollable\n * @property {number} clientWidth - width of scrollable area.\n * @property {number} clientHeight - height of scrollable area.\n * @property {number} scrollWidth - width of inner content.\n * @property {number} scrollHeight - height of inner content.\n * @property {number} clientX - X of scrollable area, document coordinate.\n * @property {number} clientY - T of scrollable area, document coordinate.\n */\n\n/**\n * @param {Element} element - A target element.\n * @param {boolean} [isWindow] - `true` if element is window.\n * @param {boolean} [dontScroll] - `true` makes it skip scroll that gets scrollWidth/Height.\n * @returns {Scrollable} Information for scroll.\n */\nfunction getScrollable(element, isWindow, dontScroll) {\n  var scrollable = {};\n  var cmpStyleHtml = void 0,\n      cmpStyleBody = void 0,\n      cmpStyleElement = void 0;\n\n  // clientWidth/Height\n  (function (target) {\n    scrollable.clientWidth = target.clientWidth;\n    scrollable.clientHeight = target.clientHeight;\n  })(isWindow ? document.documentElement : element);\n\n  // scrollWidth/Height\n  /*\n    Gecko bug, bottom-padding of element is reduced.\n    Blink for Android bug, borders of <html> is rendered but those are not added to scrollW/H.\n    Then, move it to max scroll position (sufficiently larger values) forcibly, and get scroll position.\n  */\n  var maxScrollLeft = 0,\n      maxScrollTop = 0;\n  if (!dontScroll) {\n    var curScrollLeft = void 0,\n        curScrollTop = void 0;\n    if (isWindow) {\n      curScrollLeft = scrollXYWindow(element, 'x');\n      curScrollTop = scrollXYWindow(element, 'y');\n      cmpStyleHtml = getComputedStyle(document.documentElement, '');\n      cmpStyleBody = getComputedStyle(document.body, '');\n      maxScrollLeft = scrollXYWindow(element, 'x', document.documentElement.scrollWidth + scrollable.clientWidth + // Blink for Android bug, scroll* returns size of smaller body\n      ['marginLeft', 'marginRight', 'borderLeftWidth', 'borderRightWidth', 'paddingLeft', 'paddingRight'].reduce(function (len, prop) {\n        return len + (parseFloat(cmpStyleHtml[prop]) || 0) + (parseFloat(cmpStyleBody[prop]) || 0);\n      }, 0));\n      maxScrollTop = scrollXYWindow(element, 'y', document.documentElement.scrollHeight + scrollable.clientHeight + ['marginTop', 'marginBottom', 'borderTopWidth', 'borderBottomWidth', 'paddingTop', 'paddingBottom'].reduce(function (len, prop) {\n        return len + (parseFloat(cmpStyleHtml[prop]) || 0) + (parseFloat(cmpStyleBody[prop]) || 0);\n      }, 0));\n\n      scrollXYWindow(element, 'x', curScrollLeft);\n      scrollXYWindow(element, 'y', curScrollTop);\n    } else {\n      curScrollLeft = scrollXYElement(element, 'x');\n      curScrollTop = scrollXYElement(element, 'y');\n      cmpStyleElement = getComputedStyle(element, '');\n      maxScrollLeft = scrollXYElement(element, 'x', element.scrollWidth + scrollable.clientWidth + // Blink for Android bug, scroll* returns size of smaller body\n      ['marginLeft', 'marginRight', 'borderLeftWidth', 'borderRightWidth', 'paddingLeft', 'paddingRight'].reduce(function (len, prop) {\n        return len + (parseFloat(cmpStyleElement[prop]) || 0);\n      }, 0));\n      maxScrollTop = scrollXYElement(element, 'y', element.scrollHeight + scrollable.clientHeight + ['marginTop', 'marginBottom', 'borderTopWidth', 'borderBottomWidth', 'paddingTop', 'paddingBottom'].reduce(function (len, prop) {\n        return len + (parseFloat(cmpStyleElement[prop]) || 0);\n      }, 0));\n\n      scrollXYElement(element, 'x', curScrollLeft);\n      scrollXYElement(element, 'y', curScrollTop);\n    }\n  }\n  scrollable.scrollWidth = scrollable.clientWidth + maxScrollLeft;\n  scrollable.scrollHeight = scrollable.clientHeight + maxScrollTop;\n\n  // clientX/Y\n  var rect = void 0;\n  if (isWindow) {\n    scrollable.clientX = scrollable.clientY = 0;\n  } else {\n    // padding-box\n    rect = element.getBoundingClientRect();\n    if (!cmpStyleElement) {\n      cmpStyleElement = getComputedStyle(element, '');\n    }\n    scrollable.clientX = rect.left + (parseFloat(cmpStyleElement.borderLeftWidth) || 0);\n    scrollable.clientY = rect.top + (parseFloat(cmpStyleElement.borderTopWidth) || 0);\n  }\n\n  return scrollable;\n}\n// [/AUTO-SCROLL]\n\n// [DEBUG]\nwindow.insProps = insProps;\nwindow.IS_WEBKIT = IS_WEBKIT;\nwindow.IS_GECKO = IS_GECKO; // [SVG/]\n// [SNAP]\nwindow.SNAP_GRAVITY = SNAP_GRAVITY;\nwindow.SNAP_CORNER = SNAP_CORNER;\nwindow.SNAP_SIDE = SNAP_SIDE;\nwindow.SNAP_EDGE = SNAP_EDGE;\nwindow.SNAP_BASE = SNAP_BASE;\nwindow.SNAP_ALL_CORNERS = SNAP_ALL_CORNERS;\nwindow.SNAP_ALL_SIDES = SNAP_ALL_SIDES;\nwindow.SNAP_ALL_EDGES = SNAP_ALL_EDGES;\n// [/SNAP]\n// [AUTO-SCROLL]\nwindow.AUTOSCROLL_SPEED = AUTOSCROLL_SPEED;\nwindow.AUTOSCROLL_SENSITIVITY = AUTOSCROLL_SENSITIVITY;\n// [/AUTO-SCROLL]\n// [/DEBUG]\n\nfunction copyTree(obj) {\n  return !obj ? obj : isObject(obj) ? Object.keys(obj).reduce(function (copyObj, key) {\n    copyObj[key] = copyTree(obj[key]);\n    return copyObj;\n  }, {}) : Array.isArray(obj) ? obj.map(copyTree) : obj;\n}\n\nfunction hasChanged(a, b) {\n  var typeA = void 0,\n      keysA = void 0;\n  return (typeof a === 'undefined' ? 'undefined' : _typeof(a)) !== (typeof b === 'undefined' ? 'undefined' : _typeof(b)) || (typeA = isObject(a) ? 'obj' : Array.isArray(a) ? 'array' : '') !== (isObject(b) ? 'obj' : Array.isArray(b) ? 'array' : '') || (typeA === 'obj' ? hasChanged(keysA = Object.keys(a).sort(), Object.keys(b).sort()) || keysA.some(function (prop) {\n    return hasChanged(a[prop], b[prop]);\n  }) : typeA === 'array' ? a.length !== b.length || a.some(function (aVal, i) {\n    return hasChanged(aVal, b[i]);\n  }) : a !== b);\n}\n\n/**\n * @param {Element} element - A target element.\n * @returns {boolean} `true` if connected element.\n */\nfunction isElement(element) {\n  return !!(element && element.nodeType === Node.ELEMENT_NODE &&\n  // element instanceof HTMLElement &&\n  typeof element.getBoundingClientRect === 'function' && !(element.compareDocumentPosition(document) & Node.DOCUMENT_POSITION_DISCONNECTED));\n}\nwindow.isElement = isElement; // [DEBUG/]\n\n/**\n * An object that simulates `DOMRect` to indicate a bounding-box.\n * @typedef {Object} BBox\n * @property {(number|null)} left - document coordinate\n * @property {(number|null)} top - document coordinate\n * @property {(number|null)} right - document coordinate\n * @property {(number|null)} bottom - document coordinate\n * @property {(number|null)} x - Substitutes for left\n * @property {(number|null)} y - Substitutes for top\n * @property {(number|null)} width\n * @property {(number|null)} height\n */\n\n/**\n * @param {Object} bBox - A target object.\n * @returns {(BBox|null)} A normalized `BBox`, or null if `bBox` is invalid.\n */\nfunction validBBox(bBox) {\n  if (!isObject(bBox)) {\n    return null;\n  }\n  var value = void 0;\n  if (isFinite(value = bBox.left) || isFinite(value = bBox.x)) {\n    bBox.left = bBox.x = value;\n  } else {\n    return null;\n  }\n  if (isFinite(value = bBox.top) || isFinite(value = bBox.y)) {\n    bBox.top = bBox.y = value;\n  } else {\n    return null;\n  }\n\n  if (isFinite(bBox.width) && bBox.width >= 0) {\n    bBox.right = bBox.left + bBox.width;\n  } else if (isFinite(bBox.right) && bBox.right >= bBox.left) {\n    bBox.width = bBox.right - bBox.left;\n  } else {\n    return null;\n  }\n  if (isFinite(bBox.height) && bBox.height >= 0) {\n    bBox.bottom = bBox.top + bBox.height;\n  } else if (isFinite(bBox.bottom) && bBox.bottom >= bBox.top) {\n    bBox.height = bBox.bottom - bBox.top;\n  } else {\n    return null;\n  }\n  return bBox;\n}\nwindow.validBBox = validBBox; // [DEBUG/]\n\n/**\n * A value that is Pixels or Ratio\n * @typedef {{value: number, isRatio: boolean}} PPValue\n */\n\nfunction validPPValue(value) {\n\n  // Get PPValue from string (all `/s` were already removed)\n  function string2PPValue(inString) {\n    var matches = /^(.+?)(%)?$/.exec(inString);\n    var value = void 0,\n        isRatio = void 0;\n    return matches && isFinite(value = parseFloat(matches[1])) ? { value: (isRatio = !!(matches[2] && value)) ? value / 100 : value, isRatio: isRatio } : null; // 0% -> 0\n  }\n\n  return isFinite(value) ? { value: value, isRatio: false } : typeof value === 'string' ? string2PPValue(value.replace(/\\s/g, '')) : null;\n}\nwindow.validPPValue = validPPValue; // [DEBUG/]\n\nfunction ppValue2OptionValue(ppValue) {\n  return ppValue.isRatio ? ppValue.value * 100 + '%' : ppValue.value;\n}\nwindow.ppValue2OptionValue = ppValue2OptionValue; // [DEBUG/]\n\nfunction resolvePPValue(ppValue, baseOrigin, baseSize) {\n  return typeof ppValue === 'number' ? ppValue : baseOrigin + ppValue.value * (ppValue.isRatio ? baseSize : 1);\n}\n\n/**\n * An object that simulates BBox but properties are PPValue.\n * @typedef {Object} PPBBox\n */\n\n/**\n * @param {Object} bBox - A target object.\n * @returns {(PPBBox|null)} A normalized `PPBBox`, or null if `bBox` is invalid.\n */\nfunction validPPBBox(bBox) {\n  if (!isObject(bBox)) {\n    return null;\n  }\n  var ppValue = void 0;\n  if ((ppValue = validPPValue(bBox.left)) || (ppValue = validPPValue(bBox.x))) {\n    bBox.left = bBox.x = ppValue;\n  } else {\n    return null;\n  }\n  if ((ppValue = validPPValue(bBox.top)) || (ppValue = validPPValue(bBox.y))) {\n    bBox.top = bBox.y = ppValue;\n  } else {\n    return null;\n  }\n\n  if ((ppValue = validPPValue(bBox.width)) && ppValue.value >= 0) {\n    bBox.width = ppValue;\n    delete bBox.right;\n  } else if (ppValue = validPPValue(bBox.right)) {\n    bBox.right = ppValue;\n    delete bBox.width;\n  } else {\n    return null;\n  }\n  if ((ppValue = validPPValue(bBox.height)) && ppValue.value >= 0) {\n    bBox.height = ppValue;\n    delete bBox.bottom;\n  } else if (ppValue = validPPValue(bBox.bottom)) {\n    bBox.bottom = ppValue;\n    delete bBox.height;\n  } else {\n    return null;\n  }\n  return bBox;\n}\nwindow.validPPBBox = validPPBBox; // [DEBUG/]\n\nfunction ppBBox2OptionObject(ppBBox) {\n  return Object.keys(ppBBox).reduce(function (obj, prop) {\n    obj[prop] = ppValue2OptionValue(ppBBox[prop]);\n    return obj;\n  }, {});\n}\nwindow.ppBBox2OptionObject = ppBBox2OptionObject; // [DEBUG/]\n\n// PPBBox -> BBox\nfunction resolvePPBBox(ppBBox, baseBBox) {\n  var prop2Axis = { left: 'x', right: 'x', x: 'x', width: 'x',\n    top: 'y', bottom: 'y', y: 'y', height: 'y' },\n      baseOriginXY = { x: baseBBox.left, y: baseBBox.top },\n      baseSizeXY = { x: baseBBox.width, y: baseBBox.height };\n  return validBBox(Object.keys(ppBBox).reduce(function (bBox, prop) {\n    bBox[prop] = resolvePPValue(ppBBox[prop], prop === 'width' || prop === 'height' ? 0 : baseOriginXY[prop2Axis[prop]], baseSizeXY[prop2Axis[prop]]);\n    return bBox;\n  }, {}));\n}\nwindow.resolvePPBBox = resolvePPBBox; // [DEBUG/]\n\n/**\n * @param {Element} element - A target element.\n * @param {?boolean} getPaddingBox - Get padding-box instead of border-box as bounding-box.\n * @returns {BBox} A bounding-box of `element`.\n */\nfunction getBBox(element, getPaddingBox) {\n  var rect = element.getBoundingClientRect(),\n      bBox = { left: rect.left, top: rect.top, width: rect.width, height: rect.height };\n  bBox.left += window.pageXOffset;\n  bBox.top += window.pageYOffset;\n  if (getPaddingBox) {\n    var style = window.getComputedStyle(element, ''),\n        borderTop = parseFloat(style.borderTopWidth) || 0,\n        borderRight = parseFloat(style.borderRightWidth) || 0,\n        borderBottom = parseFloat(style.borderBottomWidth) || 0,\n        borderLeft = parseFloat(style.borderLeftWidth) || 0;\n    bBox.left += borderLeft;\n    bBox.top += borderTop;\n    bBox.width -= borderLeft + borderRight;\n    bBox.height -= borderTop + borderBottom;\n  }\n  return validBBox(bBox);\n}\nwindow.getBBox = getBBox; // [DEBUG/]\n\n/**\n * Optimize an element for animation.\n * @param {Element} element - A target element.\n * @param {?boolean} gpuTrigger - Initialize for SVGElement if `true`.\n * @returns {Element} A target element.\n */\nfunction initAnim(element, gpuTrigger) {\n  var style = element.style;\n  style.webkitTapHighlightColor = 'transparent';\n\n  // Only when it has no shadow\n  var cssPropBoxShadow = CSSPrefix.getName('boxShadow'),\n      boxShadow = window.getComputedStyle(element, '')[cssPropBoxShadow];\n  if (!boxShadow || boxShadow === 'none') {\n    style[cssPropBoxShadow] = '0 0 1px transparent';\n  }\n\n  if (gpuTrigger && cssPropTransform) {\n    style[cssPropTransform] = 'translateZ(0)';\n  }\n  return element;\n}\n\nfunction setDraggableCursor(element, orgCursor) {\n  if (cssValueDraggableCursor == null) {\n    if (cssWantedValueDraggableCursor !== false) {\n      cssValueDraggableCursor = CSSPrefix.getValue('cursor', cssWantedValueDraggableCursor);\n    }\n    // The wanted value was denied, or changing is not wanted.\n    if (cssValueDraggableCursor == null) {\n      cssValueDraggableCursor = false;\n    }\n  }\n  // Update it to change a state even if cssValueDraggableCursor is false.\n  element.style.cursor = cssValueDraggableCursor === false ? orgCursor : cssValueDraggableCursor;\n}\n\nfunction setDraggingCursor(element) {\n  if (cssValueDraggingCursor == null) {\n    if (cssWantedValueDraggingCursor !== false) {\n      cssValueDraggingCursor = CSSPrefix.getValue('cursor', cssWantedValueDraggingCursor);\n    }\n    // The wanted value was denied, or changing is not wanted.\n    if (cssValueDraggingCursor == null) {\n      cssValueDraggingCursor = false;\n    }\n  }\n  if (cssValueDraggingCursor !== false) {\n    element.style.cursor = cssValueDraggingCursor;\n  }\n}\n\n// [SVG]\n/**\n * Get SVG coordinates from viewport coordinates.\n * @param {props} props - `props` of instance.\n * @param {number} clientX - viewport X.\n * @param {number} clientY - viewport Y.\n * @returns {SVGPoint} SVG coordinates.\n */\nfunction viewPoint2SvgPoint(props, clientX, clientY) {\n  var svgPoint = props.svgPoint;\n  svgPoint.x = clientX;\n  svgPoint.y = clientY;\n  return svgPoint.matrixTransform(props.svgCtmElement.getScreenCTM().inverse());\n}\n// [/SVG]\n\n/**\n * Move by `translate`.\n * @param {props} props - `props` of instance.\n * @param {{left: number, top: number}} position - New position.\n * @returns {boolean} `true` if it was moved.\n */\nfunction moveTranslate(props, position) {\n  var elementBBox = props.elementBBox;\n  if (position.left !== elementBBox.left || position.top !== elementBBox.top) {\n    var offset = props.htmlOffset;\n    props.elementStyle[cssPropTransform] = 'translate(' + (position.left + offset.left) + 'px, ' + (position.top + offset.top) + 'px)';\n    return true;\n  }\n  return false;\n}\n\n// [LEFTTOP]\n/**\n * Move by `left` and `top`.\n * @param {props} props - `props` of instance.\n * @param {{left: number, top: number}} position - New position.\n * @returns {boolean} `true` if it was moved.\n */\nfunction moveLeftTop(props, position) {\n  var elementBBox = props.elementBBox,\n      elementStyle = props.elementStyle,\n      offset = props.htmlOffset;\n  var moved = false;\n  if (position.left !== elementBBox.left) {\n    elementStyle.left = position.left + offset.left + 'px';\n    moved = true;\n  }\n  if (position.top !== elementBBox.top) {\n    elementStyle.top = position.top + offset.top + 'px';\n    moved = true;\n  }\n  return moved;\n}\n// [/LEFTTOP]\n\n// [SVG]\n/**\n * Move SVGElement.\n * @param {props} props - `props` of instance.\n * @param {{left: number, top: number}} position - New position.\n * @returns {boolean} `true` if it was moved.\n */\nfunction moveSvg(props, position) {\n  var elementBBox = props.elementBBox;\n  if (position.left !== elementBBox.left || position.top !== elementBBox.top) {\n    var offset = props.svgOffset,\n        originBBox = props.svgOriginBBox,\n        point = viewPoint2SvgPoint(props, position.left - window.pageXOffset, position.top - window.pageYOffset);\n    props.svgTransform.setTranslate(point.x + offset.x - originBBox.x, point.y + offset.y - originBBox.y);\n    return true;\n  }\n  return false;\n}\n// [/SVG]\n\n/**\n * Set `props.element` position.\n * @param {props} props - `props` of instance.\n * @param {{left: number, top: number}} position - New position.\n * @param {function} [cbCheck] - Callback that is called with valid position, cancel moving if it returns `false`.\n * @returns {boolean} `true` if it was moved.\n */\nfunction move(props, position, cbCheck) {\n  var elementBBox = props.elementBBox;\n\n  function fix() {\n    if (props.minLeft >= props.maxLeft) {\n      // Disabled\n      position.left = elementBBox.left;\n    } else if (position.left < props.minLeft) {\n      position.left = props.minLeft;\n    } else if (position.left > props.maxLeft) {\n      position.left = props.maxLeft;\n    }\n    if (props.minTop >= props.maxTop) {\n      // Disabled\n      position.top = elementBBox.top;\n    } else if (position.top < props.minTop) {\n      position.top = props.minTop;\n    } else if (position.top > props.maxTop) {\n      position.top = props.maxTop;\n    }\n  }\n\n  fix();\n  if (cbCheck) {\n    if (cbCheck(position) === false) {\n      return false;\n    }\n    fix(); // Again\n  }\n\n  var moved = props.moveElm(props, position);\n  if (moved) {\n    // Update elementBBox\n    props.elementBBox = validBBox({ left: position.left, top: position.top,\n      width: elementBBox.width, height: elementBBox.height });\n  }\n  return moved;\n}\n\n/**\n * Initialize HTMLElement for `translate`, and get `offset` that is used by `moveTranslate`.\n * @param {props} props - `props` of instance.\n * @returns {BBox} Current BBox without animation, i.e. left/top properties.\n */\nfunction initTranslate(props) {\n  var element = props.element,\n      elementStyle = props.elementStyle,\n      curPosition = getBBox(element),\n      // Get BBox before change style.\n  RESTORE_PROPS = ['display', 'marginTop', 'marginBottom', 'width', 'height'];\n  RESTORE_PROPS.unshift(cssPropTransform);\n\n  // Reset `transition-property` every time because it might be changed frequently.\n  var orgTransitionProperty = elementStyle[cssPropTransitionProperty];\n  elementStyle[cssPropTransitionProperty] = 'none'; // Disable animation\n  var fixPosition = getBBox(element);\n\n  if (!props.orgStyle) {\n    props.orgStyle = RESTORE_PROPS.reduce(function (orgStyle, prop) {\n      orgStyle[prop] = elementStyle[prop] || '';\n      return orgStyle;\n    }, {});\n    props.lastStyle = {};\n  } else {\n    RESTORE_PROPS.forEach(function (prop) {\n      // Skip this if it seems user changed it. (it can't check perfectly.)\n      if (props.lastStyle[prop] == null || elementStyle[prop] === props.lastStyle[prop]) {\n        elementStyle[prop] = props.orgStyle[prop];\n      }\n    });\n  }\n\n  var orgSize = getBBox(element),\n      cmpStyle = window.getComputedStyle(element, '');\n  // https://www.w3.org/TR/css-transforms-1/#transformable-element\n  if (cmpStyle.display === 'inline') {\n    elementStyle.display = 'inline-block';\n    ['Top', 'Bottom'].forEach(function (dirProp) {\n      var padding = parseFloat(cmpStyle['padding' + dirProp]);\n      // paddingTop/Bottom make padding but don't make space -> negative margin in inline-block\n      // marginTop/Bottom don't work in inline element -> `0` in inline-block\n      elementStyle['margin' + dirProp] = padding ? '-' + padding + 'px' : '0';\n    });\n  }\n  elementStyle[cssPropTransform] = 'translate(0, 0)';\n  // Get document offset.\n  var newBBox = getBBox(element);\n  var offset = props.htmlOffset = { left: newBBox.left ? -newBBox.left : 0, top: newBBox.top ? -newBBox.top : 0 }; // avoid `-0`\n\n  // Restore position\n  elementStyle[cssPropTransform] = 'translate(' + (curPosition.left + offset.left) + 'px, ' + (curPosition.top + offset.top) + 'px)';\n  // Restore size\n  ['width', 'height'].forEach(function (prop) {\n    if (newBBox[prop] !== orgSize[prop]) {\n      // Ignore `box-sizing`\n      elementStyle[prop] = orgSize[prop] + 'px';\n      newBBox = getBBox(element);\n      if (newBBox[prop] !== orgSize[prop]) {\n        // Retry\n        elementStyle[prop] = orgSize[prop] - (newBBox[prop] - orgSize[prop]) + 'px';\n      }\n    }\n    props.lastStyle[prop] = elementStyle[prop];\n  });\n\n  // Restore `transition-property`\n  element.offsetWidth; /* force reflow */ // eslint-disable-line no-unused-expressions\n  elementStyle[cssPropTransitionProperty] = orgTransitionProperty;\n  if (fixPosition.left !== curPosition.left || fixPosition.top !== curPosition.top) {\n    // It seems that it is moving.\n    elementStyle[cssPropTransform] = 'translate(' + (fixPosition.left + offset.left) + 'px, ' + (fixPosition.top + offset.top) + 'px)';\n  }\n\n  return fixPosition;\n}\n\n// [LEFTTOP]\n/**\n * Initialize HTMLElement for `left` and `top`, and get `offset` that is used by `moveLeftTop`.\n * @param {props} props - `props` of instance.\n * @returns {BBox} Current BBox without animation, i.e. left/top properties.\n */\nfunction initLeftTop(props) {\n  var element = props.element,\n      elementStyle = props.elementStyle,\n      curPosition = getBBox(element),\n      // Get BBox before change style.\n  RESTORE_PROPS = ['position', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'width', 'height'];\n\n  // Reset `transition-property` every time because it might be changed frequently.\n  var orgTransitionProperty = elementStyle[cssPropTransitionProperty];\n  elementStyle[cssPropTransitionProperty] = 'none'; // Disable animation\n  var fixPosition = getBBox(element);\n\n  if (!props.orgStyle) {\n    props.orgStyle = RESTORE_PROPS.reduce(function (orgStyle, prop) {\n      orgStyle[prop] = elementStyle[prop] || '';\n      return orgStyle;\n    }, {});\n    props.lastStyle = {};\n  } else {\n    RESTORE_PROPS.forEach(function (prop) {\n      // Skip this if it seems user changed it. (it can't check perfectly.)\n      if (props.lastStyle[prop] == null || elementStyle[prop] === props.lastStyle[prop]) {\n        elementStyle[prop] = props.orgStyle[prop];\n      }\n    });\n  }\n\n  var orgSize = getBBox(element);\n  elementStyle.position = 'absolute';\n  elementStyle.left = elementStyle.top = elementStyle.margin = '0';\n  // Get document offset.\n  var newBBox = getBBox(element);\n  var offset = props.htmlOffset = { left: newBBox.left ? -newBBox.left : 0, top: newBBox.top ? -newBBox.top : 0 }; // avoid `-0`\n\n  // Restore position\n  elementStyle.left = curPosition.left + offset.left + 'px';\n  elementStyle.top = curPosition.top + offset.top + 'px';\n  // Restore size\n  ['width', 'height'].forEach(function (prop) {\n    if (newBBox[prop] !== orgSize[prop]) {\n      // Ignore `box-sizing`\n      elementStyle[prop] = orgSize[prop] + 'px';\n      newBBox = getBBox(element);\n      if (newBBox[prop] !== orgSize[prop]) {\n        // Retry\n        elementStyle[prop] = orgSize[prop] - (newBBox[prop] - orgSize[prop]) + 'px';\n      }\n    }\n    props.lastStyle[prop] = elementStyle[prop];\n  });\n\n  // Restore `transition-property`\n  element.offsetWidth; /* force reflow */ // eslint-disable-line no-unused-expressions\n  elementStyle[cssPropTransitionProperty] = orgTransitionProperty;\n  if (fixPosition.left !== curPosition.left || fixPosition.top !== curPosition.top) {\n    // It seems that it is moving.\n    elementStyle.left = fixPosition.left + offset.left + 'px';\n    elementStyle.top = fixPosition.top + offset.top + 'px';\n  }\n\n  return fixPosition;\n}\n// [/LEFTTOP]\n\n// [SVG]\n/**\n * Initialize SVGElement, and get `offset` that is used by `moveSvg`.\n * @param {props} props - `props` of instance.\n * @returns {BBox} Current BBox without animation, i.e. left/top properties.\n */\nfunction initSvg(props) {\n  var element = props.element,\n      svgTransform = props.svgTransform,\n      curRect = element.getBoundingClientRect(),\n      // Get Rect before change position.\n  fixPosition = getBBox(element);\n\n  svgTransform.setTranslate(0, 0);\n  var originBBox = props.svgOriginBBox = element.getBBox(),\n\n  // Try to get SVG coordinates of current position.\n  newRect = element.getBoundingClientRect(),\n      originPoint = viewPoint2SvgPoint(props, newRect.left, newRect.top),\n\n  // Gecko bug, getScreenCTM returns incorrect CTM, and originPoint might not be current position.\n  offset = props.svgOffset = { x: originBBox.x - originPoint.x, y: originBBox.y - originPoint.y },\n\n\n  // Restore position\n  curPoint = viewPoint2SvgPoint(props, curRect.left, curRect.top);\n  svgTransform.setTranslate(curPoint.x + offset.x - originBBox.x, curPoint.y + offset.y - originBBox.y);\n\n  return fixPosition;\n}\n// [/SVG]\n\n/**\n * Set `elementBBox`, `containmentBBox`, `min/max``Left/Top` and `snapTargets`.\n * @param {props} props - `props` of instance.\n * @param {string} [eventType] - A type of event that kicked this method.\n * @returns {void}\n */\nfunction initBBox(props, eventType) {\n  var docBBox = getBBox(document.documentElement),\n      elementBBox = props.elementBBox = props.initElm(props),\n      // reset offset etc.\n  containmentBBox = props.containmentBBox = props.containmentIsBBox ? resolvePPBBox(props.options.containment, docBBox) || docBBox : getBBox(props.options.containment, true);\n  props.minLeft = containmentBBox.left;\n  props.maxLeft = containmentBBox.right - elementBBox.width;\n  props.minTop = containmentBBox.top;\n  props.maxTop = containmentBBox.bottom - elementBBox.height;\n  // Adjust position\n  move(props, { left: elementBBox.left, top: elementBBox.top });\n\n  // [SNAP]\n\n  // Snap-targets\n\n  /**\n   * @typedef {Object} SnapTarget\n   * @property {number} [x] - A coordinate it moves to. It has x or y or both.\n   * @property {number} [y]\n   * @property {number} [gravityXStart] - Gravity zone. It has *Start or *End or both, and *X* or *Y* or both.\n   * @property {number} [gravityXEnd]\n   * @property {number} [gravityYStart]\n   * @property {number} [gravityYEnd]\n   */\n\n  if (props.parsedSnapTargets) {\n    var elementSizeXY = { x: elementBBox.width, y: elementBBox.height },\n        minXY = { x: props.minLeft, y: props.minTop },\n        maxXY = { x: props.maxLeft, y: props.maxTop },\n        prop2Axis = { left: 'x', right: 'x', x: 'x', width: 'x', xStart: 'x', xEnd: 'x', xStep: 'x',\n      top: 'y', bottom: 'y', y: 'y', height: 'y', yStart: 'y', yEnd: 'y', yStep: 'y' },\n        snapTargets = props.parsedSnapTargets.reduce(function (snapTargets, parsedSnapTarget) {\n      var baseRect = parsedSnapTarget.base === 'containment' ? containmentBBox : docBBox,\n          baseOriginXY = { x: baseRect.left, y: baseRect.top },\n          baseSizeXY = { x: baseRect.width, y: baseRect.height };\n\n      /**\n       * Basically, shallow copy from parsedSnapTarget, and it can have resolved values.\n       * @typedef {{x: (number|PPValue), y, xStart, xEnd, xStep, yStart, yEnd, yStep}} TargetXY\n       * @property {string[]} [corners] - Applied value.\n       * @property {string[]} [sides]\n       * @property {boolean} center\n       * @property {number} [xGravity] - Override parsedSnapTarget.gravity.\n       * @property {number} [yGravity]\n       */\n\n      // Add single Point or Line (i.e. targetXY has no *Step)\n      function addSnapTarget(targetXY) {\n        if (targetXY.center == null) {\n          targetXY.center = parsedSnapTarget.center;\n        }\n        if (targetXY.xGravity == null) {\n          targetXY.xGravity = parsedSnapTarget.gravity;\n        }\n        if (targetXY.yGravity == null) {\n          targetXY.yGravity = parsedSnapTarget.gravity;\n        }\n\n        if (targetXY.x != null && targetXY.y != null) {\n          // Point\n          targetXY.x = resolvePPValue(targetXY.x, baseOriginXY.x, baseSizeXY.x);\n          targetXY.y = resolvePPValue(targetXY.y, baseOriginXY.y, baseSizeXY.y);\n\n          if (targetXY.center) {\n            targetXY.x -= elementSizeXY.x / 2;\n            targetXY.y -= elementSizeXY.y / 2;\n            targetXY.corners = ['tl'];\n          }\n\n          (targetXY.corners || parsedSnapTarget.corners).forEach(function (corner) {\n            var x = targetXY.x - (corner === 'tr' || corner === 'br' ? elementSizeXY.x : 0),\n                y = targetXY.y - (corner === 'bl' || corner === 'br' ? elementSizeXY.y : 0);\n            if (x >= minXY.x && x <= maxXY.x && y >= minXY.y && y <= maxXY.y) {\n              var snapTarget = { x: x, y: y },\n                  gravityXStart = x - targetXY.xGravity,\n                  gravityXEnd = x + targetXY.xGravity,\n                  gravityYStart = y - targetXY.yGravity,\n                  gravityYEnd = y + targetXY.yGravity;\n              if (gravityXStart > minXY.x) {\n                snapTarget.gravityXStart = gravityXStart;\n              }\n              if (gravityXEnd < maxXY.x) {\n                snapTarget.gravityXEnd = gravityXEnd;\n              }\n              if (gravityYStart > minXY.y) {\n                snapTarget.gravityYStart = gravityYStart;\n              }\n              if (gravityYEnd < maxXY.y) {\n                snapTarget.gravityYEnd = gravityYEnd;\n              }\n              snapTargets.push(snapTarget);\n            }\n          });\n        } else {\n          // Line\n          var specAxis = targetXY.x != null ? 'x' : 'y',\n              rangeAxis = specAxis === 'x' ? 'y' : 'x',\n              startProp = rangeAxis + 'Start',\n              endProp = rangeAxis + 'End',\n              gravityProp = specAxis + 'Gravity',\n              specAxisL = specAxis.toUpperCase(),\n              rangeAxisL = rangeAxis.toUpperCase(),\n              gravitySpecStartProp = 'gravity' + specAxisL + 'Start',\n              gravitySpecEndProp = 'gravity' + specAxisL + 'End',\n              gravityRangeStartProp = 'gravity' + rangeAxisL + 'Start',\n              gravityRangeEndProp = 'gravity' + rangeAxisL + 'End';\n          targetXY[specAxis] = resolvePPValue(targetXY[specAxis], baseOriginXY[specAxis], baseSizeXY[specAxis]);\n          targetXY[startProp] = resolvePPValue(targetXY[startProp], baseOriginXY[rangeAxis], baseSizeXY[rangeAxis]);\n          targetXY[endProp] = resolvePPValue(targetXY[endProp], baseOriginXY[rangeAxis], baseSizeXY[rangeAxis]) - elementSizeXY[rangeAxis]; // Reduce the end of the line.\n          if (targetXY[startProp] > targetXY[endProp] || // Smaller than element size.\n          targetXY[startProp] > maxXY[rangeAxis] || targetXY[endProp] < minXY[rangeAxis]) {\n            return;\n          }\n\n          if (targetXY.center) {\n            targetXY[specAxis] -= elementSizeXY[specAxis] / 2;\n            targetXY.sides = ['start'];\n          }\n\n          (targetXY.sides || parsedSnapTarget.sides).forEach(function (side) {\n            var xy = targetXY[specAxis] - (side === 'end' ? elementSizeXY[specAxis] : 0);\n            if (xy >= minXY[specAxis] && xy <= maxXY[specAxis]) {\n              var snapTarget = {},\n                  gravitySpecStart = xy - targetXY[gravityProp],\n                  gravitySpecEnd = xy + targetXY[gravityProp];\n              snapTarget[specAxis] = xy;\n              if (gravitySpecStart > minXY[specAxis]) {\n                snapTarget[gravitySpecStartProp] = gravitySpecStart;\n              }\n              if (gravitySpecEnd < maxXY[specAxis]) {\n                snapTarget[gravitySpecEndProp] = gravitySpecEnd;\n              }\n              if (targetXY[startProp] > minXY[rangeAxis]) {\n                snapTarget[gravityRangeStartProp] = targetXY[startProp];\n              }\n              if (targetXY[endProp] < maxXY[rangeAxis]) {\n                snapTarget[gravityRangeEndProp] = targetXY[endProp];\n              }\n              snapTargets.push(snapTarget);\n            }\n          });\n        }\n      }\n\n      var bBox = void 0;\n      if ((bBox = parsedSnapTarget.element ? getBBox(parsedSnapTarget.element) : null) || // Element\n      parsedSnapTarget.ppBBox) {\n        if (parsedSnapTarget.ppBBox) {\n          bBox = resolvePPBBox(parsedSnapTarget.ppBBox, baseRect);\n        } // BBox\n        if (bBox) {\n          // Drop invalid BBox.\n          // Expand into 4 lines.\n          parsedSnapTarget.edges.forEach(function (edge) {\n            var lengthenX = parsedSnapTarget.gravity,\n                lengthenY = parsedSnapTarget.gravity;\n            if (edge === 'outside') {\n              // Snap it when a part of the element is part of the range.\n              lengthenX += elementBBox.width;\n              lengthenY += elementBBox.height;\n            }\n            var xStart = bBox.left - lengthenX,\n                xEnd = bBox.right + lengthenX,\n                yStart = bBox.top - lengthenY,\n                yEnd = bBox.bottom + lengthenY;\n            var side = edge === 'inside' ? 'start' : 'end';\n            addSnapTarget({ xStart: xStart, xEnd: xEnd, y: bBox.top, sides: [side], center: false }); // Top\n            addSnapTarget({ x: bBox.left, yStart: yStart, yEnd: yEnd, sides: [side], center: false }); // Left\n            side = edge === 'inside' ? 'end' : 'start';\n            addSnapTarget({ xStart: xStart, xEnd: xEnd, y: bBox.bottom, sides: [side], center: false }); // Bottom\n            addSnapTarget({ x: bBox.right, yStart: yStart, yEnd: yEnd, sides: [side], center: false }); // Right\n          });\n        }\n      } else {\n        var expanded = [['x', 'y', 'xStart', 'xEnd', 'xStep', 'yStart', 'yEnd', 'yStep'].reduce(function (targetXY, prop) {\n          if (parsedSnapTarget[prop]) {\n            targetXY[prop] = resolvePPValue(parsedSnapTarget[prop], prop === 'xStep' || prop === 'yStep' ? 0 : baseOriginXY[prop2Axis[prop]], baseSizeXY[prop2Axis[prop]]);\n          }\n          return targetXY;\n        }, {})];\n\n        ['x', 'y'].forEach(function (axis) {\n          var startProp = axis + 'Start',\n              endProp = axis + 'End',\n              stepProp = axis + 'Step',\n              gravityProp = axis + 'Gravity';\n          expanded = expanded.reduce(function (expanded, targetXY) {\n            var start = targetXY[startProp],\n                end = targetXY[endProp],\n                step = targetXY[stepProp];\n            if (start != null && end != null && start >= end) {\n              return expanded;\n            } // start >= end\n\n            if (step != null) {\n              if (step < 2) {\n                return expanded;\n              }\n              // step >= 2px -> Expand by step\n              var gravity = step / 2; // max\n              gravity = parsedSnapTarget.gravity > gravity ? gravity : null;\n              for (var curValue = start; curValue <= end; curValue += step) {\n                var expandedXY = Object.keys(targetXY).reduce(function (expandedXY, prop) {\n                  if (prop !== startProp && prop !== endProp && prop !== stepProp) {\n                    expandedXY[prop] = targetXY[prop];\n                  }\n                  return expandedXY;\n                }, {});\n                expandedXY[axis] = curValue;\n                expandedXY[gravityProp] = gravity;\n                expanded.push(expandedXY);\n              }\n            } else {\n              expanded.push(targetXY);\n            }\n            return expanded;\n          }, []);\n        });\n        expanded.forEach(function (targetXY) {\n          addSnapTarget(targetXY);\n        });\n      }\n\n      return snapTargets;\n    }, []);\n\n    props.snapTargets = snapTargets.length ? snapTargets : null;\n  }\n  // [/SNAP]\n\n  // [AUTO-SCROLL]\n  var autoScroll = {},\n      autoScrollOptions = props.options.autoScroll;\n  if (autoScrollOptions) {\n    autoScroll.isWindow = autoScrollOptions.target === window;\n    autoScroll.target = autoScrollOptions.target;\n\n    var dontScroll = eventType === 'scroll',\n        // Avoid duplicated calling\n    scrollable = getScrollable(autoScrollOptions.target, autoScroll.isWindow, dontScroll),\n        scrollableBBox = validBBox({ left: scrollable.clientX, top: scrollable.clientY,\n      width: scrollable.clientWidth, height: scrollable.clientHeight });\n    autoScroll.scrollableBBox = scrollableBBox; // [DEBUG/]\n\n    if (!dontScroll) {\n      autoScroll.scrollWidth = scrollable.scrollWidth;\n      autoScroll.scrollHeight = scrollable.scrollHeight;\n    } else if (props.autoScroll) {\n      autoScroll.scrollWidth = props.autoScroll.scrollWidth;\n      autoScroll.scrollHeight = props.autoScroll.scrollHeight;\n    }\n\n    [['X', 'Width', 'left', 'right'], ['Y', 'Height', 'top', 'bottom']].forEach(function (axis) {\n      var xy = axis[0],\n          wh = axis[1],\n          back = axis[2],\n          forward = axis[3],\n          maxAbs = (autoScroll['scroll' + wh] || 0) - scrollable['client' + wh],\n          min = autoScrollOptions['min' + xy] || 0;\n      var max = isFinite(autoScrollOptions['max' + xy]) ? autoScrollOptions['max' + xy] : maxAbs;\n      if (min < max && min < maxAbs) {\n        if (max > maxAbs) {\n          max = maxAbs;\n        }\n\n        var lines = [],\n            elementSize = elementBBox[wh.toLowerCase()];\n        for (var i = autoScrollOptions.sensitivity.length - 1; i >= 0; i--) {\n          // near -> far\n          var sensitivity = autoScrollOptions.sensitivity[i],\n              speed = autoScrollOptions.speed[i];\n          // back\n          lines.push({ dir: -1, speed: speed,\n            position: scrollableBBox[back] + sensitivity });\n          // forward\n          lines.push({ dir: 1, speed: speed,\n            position: scrollableBBox[forward] - sensitivity - elementSize });\n        }\n\n        autoScroll[xy.toLowerCase()] = { min: min, max: max, lines: lines };\n      }\n    });\n  }\n  props.autoScroll = autoScroll.x || autoScroll.y ? autoScroll : null;\n  // [/AUTO-SCROLL]\n  window.initBBoxDone = true; // [DEBUG/]\n}\n\n/**\n * @param {props} props - `props` of instance.\n * @returns {void}\n */\nfunction dragEnd(props) {\n  scrollFrame.stop(); // [AUTO-SCROLL/]\n  setDraggableCursor(props.options.handle, props.orgCursor);\n  body.style.cursor = cssOrgValueBodyCursor;\n\n  if (props.options.zIndex !== false) {\n    props.elementStyle.zIndex = props.orgZIndex;\n  }\n  if (cssPropUserSelect) {\n    body.style[cssPropUserSelect] = cssOrgValueBodyUserSelect;\n  }\n  var classList = mClassList(props.element);\n  if (movingClass) {\n    classList.remove(movingClass);\n  }\n  if (draggingClass) {\n    classList.remove(draggingClass);\n  }\n\n  activeItem = null;\n  if (props.onDragEnd) {\n    props.onDragEnd();\n  }\n}\n\n/**\n * @param {props} props - `props` of instance.\n * @param {{clientX, clientY}} pointerXY - This might be MouseEvent, Touch of TouchEvent or Object.\n * @returns {boolean} `true` if it started.\n */\nfunction dragStart(props, pointerXY) {\n  if (props.disabled) {\n    return false;\n  }\n  if (activeItem) {\n    dragEnd(activeItem);\n  } // activeItem is normally null by pointerEvent.end.\n\n  setDraggingCursor(props.options.handle);\n  body.style.cursor = cssValueDraggingCursor || // If it is `false` or `''`\n  window.getComputedStyle(props.options.handle, '').cursor;\n\n  if (props.options.zIndex !== false) {\n    props.elementStyle.zIndex = props.options.zIndex;\n  }\n  if (cssPropUserSelect) {\n    body.style[cssPropUserSelect] = 'none';\n  }\n  if (draggingClass) {\n    mClassList(props.element).add(draggingClass);\n  }\n\n  activeItem = props;\n  hasMoved = false;\n  pointerOffset.left = props.elementBBox.left - (pointerXY.clientX + window.pageXOffset);\n  pointerOffset.top = props.elementBBox.top - (pointerXY.clientY + window.pageYOffset);\n  return true;\n}\n\n/**\n * @param {props} props - `props` of instance.\n * @param {Object} newOptions - New options.\n * @returns {void}\n */\nfunction _setOptions(props, newOptions) {\n  var options = props.options;\n  var needsInitBBox = void 0;\n\n  // containment\n  if (newOptions.containment) {\n    var bBox = void 0;\n    if (isElement(newOptions.containment)) {\n      // Specific element\n      if (newOptions.containment !== options.containment) {\n        options.containment = newOptions.containment;\n        props.containmentIsBBox = false;\n        needsInitBBox = true;\n      }\n    } else if ((bBox = validPPBBox(copyTree(newOptions.containment))) && // bBox\n    hasChanged(bBox, options.containment)) {\n      options.containment = bBox;\n      props.containmentIsBBox = true;\n      needsInitBBox = true;\n    }\n  }\n\n  // [SNAP]\n\n  /**\n   * @typedef {Object} SnapOptions\n   * @property {SnapTargetOptions[]} targets\n   * @property {number} [gravity]\n   * @property {string} [corner]\n   * @property {string} [side]\n   * @property {boolean} [center]\n   * @property {string} [edge]\n   * @property {string} [base]\n   */\n\n  /**\n   * @typedef {Object} SnapTargetOptions\n   * @property {(number|string)} [x] - pixels | '<n>%' | {start, end} | {step, start, end}\n   * @property {(number|string)} [y]\n   * @property {(Element|Object)} [boundingBox] - Object has properties that are string or number from PPBBox.\n   * @property {number} [gravity]\n   * @property {string} [corner]\n   * @property {string} [side]\n   * @property {boolean} [center]\n   * @property {string} [edge]\n   * @property {string} [base]\n   */\n\n  /**\n   * @typedef {Object} ParsedSnapTarget\n   * @property {PPValue} [x] - (input: pixels | '<n>%')\n   * @property {PPValue} [y]\n   * @property {PPValue} [xStart] - (input: {start, end} | {step, start, end})\n   * @property {PPValue} [xEnd]\n   * @property {PPValue} [xStep] - (input: {step, start, end})\n   * @property {PPValue} [yStart]\n   * @property {PPValue} [yEnd]\n   * @property {PPValue} [yStep]\n   * @property {Element} [element]\n   * @property {PPBBox} [ppBBox]\n   * @property {number} gravity\n   * @property {string[]} corners\n   * @property {string[]} sides\n   * @property {boolean} center\n   * @property {string[]} edges\n   * @property {string} base\n   */\n\n  // Normalize `gravity`, `corner`, `side`, `center`, `edge`, `base`\n  function commonSnapOptions(options, newOptions) {\n    function cleanString(inString) {\n      return typeof inString === 'string' ? inString.replace(/[, ]+/g, ' ').trim().toLowerCase() : null;\n    }\n\n    // gravity\n    if (isFinite(newOptions.gravity) && newOptions.gravity > 0) {\n      options.gravity = newOptions.gravity;\n    }\n    // corner\n    var corner = cleanString(newOptions.corner);\n    if (corner) {\n      if (corner !== 'all') {\n        var added = {},\n            corners = corner.split(/\\s/).reduce(function (corners, corner) {\n          corner = corner.trim().replace(/^(.).*?-(.).*$/, '$1$2');\n          if ((corner = corner === 'tl' || corner === 'lt' ? 'tl' : corner === 'tr' || corner === 'rt' ? 'tr' : corner === 'bl' || corner === 'lb' ? 'bl' : corner === 'br' || corner === 'rb' ? 'br' : null) && !added[corner]) {\n            corners.push(corner);\n            added[corner] = true;\n          }\n          return corners;\n        }, []),\n            cornersLen = corners.length;\n        corner = !cornersLen ? null : cornersLen === 4 ? 'all' : corners.join(' ');\n      }\n      if (corner) {\n        options.corner = corner;\n      }\n    }\n    // side\n    var side = cleanString(newOptions.side);\n    if (side) {\n      if (side === 'start' || side === 'end' || side === 'both') {\n        options.side = side;\n      } else if (side === 'start end' || side === 'end start') {\n        options.side = 'both';\n      }\n    }\n    // center\n    if (typeof newOptions.center === 'boolean') {\n      options.center = newOptions.center;\n    }\n    // edge\n    var edge = cleanString(newOptions.edge);\n    if (edge) {\n      if (edge === 'inside' || edge === 'outside' || edge === 'both') {\n        options.edge = edge;\n      } else if (edge === 'inside outside' || edge === 'outside inside') {\n        options.edge = 'both';\n      }\n    }\n    // base\n    var base = typeof newOptions.base === 'string' ? newOptions.base.trim().toLowerCase() : null;\n    if (base && (base === 'containment' || base === 'document')) {\n      options.base = base;\n    }\n    return options;\n  }\n  window.commonSnapOptions = commonSnapOptions; // [DEBUG/]\n\n  // snap\n  if (newOptions.snap != null) {\n    var newSnapOptions = isObject(newOptions.snap) && newOptions.snap.targets != null ? newOptions.snap : { targets: newOptions.snap },\n        snapTargetsOptions = [],\n        snapOptions = commonSnapOptions({ targets: snapTargetsOptions }, newSnapOptions);\n\n    // Set default options into top level.\n    if (!snapOptions.gravity) {\n      snapOptions.gravity = SNAP_GRAVITY;\n    }\n    if (!snapOptions.corner) {\n      snapOptions.corner = SNAP_CORNER;\n    }\n    if (!snapOptions.side) {\n      snapOptions.side = SNAP_SIDE;\n    }\n    if (typeof snapOptions.center !== 'boolean') {\n      snapOptions.center = false;\n    }\n    if (!snapOptions.edge) {\n      snapOptions.edge = SNAP_EDGE;\n    }\n    if (!snapOptions.base) {\n      snapOptions.base = SNAP_BASE;\n    }\n\n    var parsedSnapTargets = (Array.isArray(newSnapOptions.targets) ? newSnapOptions.targets : [newSnapOptions.targets]).reduce(function (parsedSnapTargets, target) {\n      if (target == null) {\n        return parsedSnapTargets;\n      }\n\n      var isElementPre = isElement(target),\n          // Pre-check direct value\n      ppBBoxPre = validPPBBox(copyTree(target)),\n          // Pre-check direct value\n      newSnapTargetOptions = isElementPre || ppBBoxPre ? { boundingBox: target } : // Direct Element | PPBBox\n      isObject(target) && target.start == null && target.end == null && target.step == null ? target : // SnapTargetOptions\n      { x: target, y: target },\n          // Others, it might be {step, start, end}\n      expandedParsedSnapTargets = [],\n          snapTargetOptions = {},\n          newOptionsBBox = newSnapTargetOptions.boundingBox;\n      var ppBBox = void 0;\n\n      if (isElementPre || isElement(newOptionsBBox)) {\n        // Element\n        expandedParsedSnapTargets.push({ element: newOptionsBBox });\n        snapTargetOptions.boundingBox = newOptionsBBox;\n      } else if (ppBBox = ppBBoxPre || validPPBBox(copyTree(newOptionsBBox))) {\n        // Object -> PPBBox\n        expandedParsedSnapTargets.push({ ppBBox: ppBBox });\n        snapTargetOptions.boundingBox = ppBBox2OptionObject(ppBBox);\n      } else {\n        var invalid = void 0; // `true` if valid PPValue was given but the contained value is invalid.\n        var parsedXY = ['x', 'y'].reduce(function (parsedXY, axis) {\n          var newOptionsXY = newSnapTargetOptions[axis];\n          var ppValue = void 0;\n\n          if (ppValue = validPPValue(newOptionsXY)) {\n            // pixels | '<n>%'\n            parsedXY[axis] = ppValue;\n            snapTargetOptions[axis] = ppValue2OptionValue(ppValue);\n          } else {\n            // {start, end} | {step, start, end}\n            var start = void 0,\n                end = void 0,\n                step = void 0;\n            if (isObject(newOptionsXY)) {\n              start = validPPValue(newOptionsXY.start);\n              end = validPPValue(newOptionsXY.end);\n              step = validPPValue(newOptionsXY.step);\n              if (start && end && start.isRatio === end.isRatio && start.value >= end.value) {\n                // start >= end\n                invalid = true;\n              }\n            }\n            start = parsedXY[axis + 'Start'] = start || { value: 0, isRatio: false };\n            end = parsedXY[axis + 'End'] = end || { value: 1, isRatio: true };\n            snapTargetOptions[axis] = { start: ppValue2OptionValue(start), end: ppValue2OptionValue(end) };\n            if (step) {\n              if (step.isRatio ? step.value > 0 : step.value >= 2) {\n                // step > 0% || step >= 2px\n                parsedXY[axis + 'Step'] = step;\n                snapTargetOptions[axis].step = ppValue2OptionValue(step);\n              } else {\n                invalid = true;\n              }\n            }\n          }\n          return parsedXY;\n        }, {});\n        if (invalid) {\n          return parsedSnapTargets;\n        }\n\n        if (parsedXY.xStart && !parsedXY.xStep && parsedXY.yStart && !parsedXY.yStep) {\n          // Expand into 4 lines. This is not BBox, and `edge` is ignored.\n          expandedParsedSnapTargets.push({ xStart: parsedXY.xStart, xEnd: parsedXY.xEnd, y: parsedXY.yStart }, // Top\n          { xStart: parsedXY.xStart, xEnd: parsedXY.xEnd, y: parsedXY.yEnd }, // Bottom\n          { x: parsedXY.xStart, yStart: parsedXY.yStart, yEnd: parsedXY.yEnd }, // Left\n          { x: parsedXY.xEnd, yStart: parsedXY.yStart, yEnd: parsedXY.yEnd // Right\n          });\n        } else {\n          expandedParsedSnapTargets.push(parsedXY);\n        }\n      }\n\n      if (expandedParsedSnapTargets.length) {\n        snapTargetsOptions.push(commonSnapOptions(snapTargetOptions, newSnapTargetOptions));\n        // Copy common SnapOptions\n        var corner = snapTargetOptions.corner || snapOptions.corner,\n            side = snapTargetOptions.side || snapOptions.side,\n            edge = snapTargetOptions.edge || snapOptions.edge,\n            commonOptions = {\n          gravity: snapTargetOptions.gravity || snapOptions.gravity,\n          base: snapTargetOptions.base || snapOptions.base,\n          center: typeof snapTargetOptions.center === 'boolean' ? snapTargetOptions.center : snapOptions.center,\n          corners: corner === 'all' ? SNAP_ALL_CORNERS : corner.split(' '), // Split\n          sides: side === 'both' ? SNAP_ALL_SIDES : [side], // Split\n          edges: edge === 'both' ? SNAP_ALL_EDGES : [edge] // Split\n        };\n        expandedParsedSnapTargets.forEach(function (parsedSnapTarget) {\n          // Set common SnapOptions\n          ['gravity', 'corners', 'sides', 'center', 'edges', 'base'].forEach(function (option) {\n            parsedSnapTarget[option] = commonOptions[option];\n          });\n          parsedSnapTargets.push(parsedSnapTarget);\n        });\n      }\n      return parsedSnapTargets;\n    }, []);\n\n    if (parsedSnapTargets.length) {\n      options.snap = snapOptions; // Update always\n      if (hasChanged(parsedSnapTargets, props.parsedSnapTargets)) {\n        props.parsedSnapTargets = parsedSnapTargets;\n        needsInitBBox = true;\n      }\n    }\n  } else if (newOptions.hasOwnProperty('snap') && props.parsedSnapTargets) {\n    options.snap = props.parsedSnapTargets = props.snapTargets = void 0;\n  }\n\n  // [/SNAP]\n\n  // [AUTO-SCROLL]\n\n  /**\n   * @typedef {Object} AutoScrollOptions\n   * @property {(Element|Window)} target\n   * @property {Array} speed\n   * @property {Array} sensitivity\n   * @property {number} [minX]\n   * @property {number} [maxX]\n   * @property {number} [minY]\n   * @property {number} [maxY]\n   */\n\n  // autoScroll\n  if (newOptions.autoScroll) {\n    var newAutoScrollOptions = isObject(newOptions.autoScroll) ? newOptions.autoScroll : { target: newOptions.autoScroll === true ? window : newOptions.autoScroll },\n        autoScrollOptions = {};\n\n    // target\n    autoScrollOptions.target = isElement(newAutoScrollOptions.target) ? newAutoScrollOptions.target : window;\n    // speed\n    autoScrollOptions.speed = [];\n    (Array.isArray(newAutoScrollOptions.speed) ? newAutoScrollOptions.speed : [newAutoScrollOptions.speed]).every(function (speed, i) {\n      if (i <= 2 && isFinite(speed)) {\n        autoScrollOptions.speed[i] = speed;\n        return true;\n      }\n      return false;\n    });\n    if (!autoScrollOptions.speed.length) {\n      autoScrollOptions.speed = AUTOSCROLL_SPEED;\n    }\n    // sensitivity\n    var newSensitivity = Array.isArray(newAutoScrollOptions.sensitivity) ? newAutoScrollOptions.sensitivity : [newAutoScrollOptions.sensitivity];\n    autoScrollOptions.sensitivity = autoScrollOptions.speed.map(function (v, i) {\n      return isFinite(newSensitivity[i]) ? newSensitivity[i] : AUTOSCROLL_SENSITIVITY[i];\n    });\n    // min*, max*\n    ['X', 'Y'].forEach(function (option) {\n      var optionMin = 'min' + option,\n          optionMax = 'max' + option;\n      if (isFinite(newAutoScrollOptions[optionMin]) && newAutoScrollOptions[optionMin] >= 0) {\n        autoScrollOptions[optionMin] = newAutoScrollOptions[optionMin];\n      }\n      if (isFinite(newAutoScrollOptions[optionMax]) && newAutoScrollOptions[optionMax] >= 0 && (!autoScrollOptions[optionMin] || newAutoScrollOptions[optionMax] >= autoScrollOptions[optionMin])) {\n        autoScrollOptions[optionMax] = newAutoScrollOptions[optionMax];\n      }\n    });\n\n    if (hasChanged(autoScrollOptions, options.autoScroll)) {\n      options.autoScroll = autoScrollOptions;\n      needsInitBBox = true;\n    }\n  } else if (newOptions.hasOwnProperty('autoScroll')) {\n    if (options.autoScroll) {\n      needsInitBBox = true;\n    }\n    options.autoScroll = void 0;\n  }\n\n  // [/AUTO-SCROLL]\n\n  if (needsInitBBox) {\n    initBBox(props);\n  }\n\n  // handle\n  if (isElement(newOptions.handle) && newOptions.handle !== options.handle) {\n    if (options.handle) {\n      // Restore\n      options.handle.style.cursor = props.orgCursor;\n      if (cssPropUserSelect) {\n        options.handle.style[cssPropUserSelect] = props.orgUserSelect;\n      }\n      // pointerEvent remove startHandler\n      pointerEvent.removeStartHandler(options.handle, props.pointerEventHandlerId);\n    }\n    var handle = options.handle = newOptions.handle;\n    props.orgCursor = handle.style.cursor;\n    setDraggableCursor(handle, props.orgCursor);\n    if (cssPropUserSelect) {\n      props.orgUserSelect = handle.style[cssPropUserSelect];\n      handle.style[cssPropUserSelect] = 'none';\n    }\n    // pointerEvent add startHandler\n    pointerEvent.addStartHandler(handle, props.pointerEventHandlerId);\n  }\n\n  // zIndex\n  if (isFinite(newOptions.zIndex) || newOptions.zIndex === false) {\n    options.zIndex = newOptions.zIndex;\n    if (props === activeItem) {\n      props.elementStyle.zIndex = options.zIndex === false ? props.orgZIndex : options.zIndex;\n    }\n  }\n\n  // left/top\n  var position = { left: props.elementBBox.left, top: props.elementBBox.top };\n  var needsMove = void 0;\n  if (isFinite(newOptions.left) && newOptions.left !== position.left) {\n    position.left = newOptions.left;\n    needsMove = true;\n  }\n  if (isFinite(newOptions.top) && newOptions.top !== position.top) {\n    position.top = newOptions.top;\n    needsMove = true;\n  }\n  if (needsMove) {\n    move(props, position);\n  }\n\n  // Event listeners\n  ['onDrag', 'onMove', 'onMoveStart', 'onDragEnd'].forEach(function (option) {\n    if (typeof newOptions[option] === 'function') {\n      options[option] = newOptions[option];\n      props[option] = options[option].bind(props.ins);\n    } else if (newOptions.hasOwnProperty(option) && newOptions[option] == null) {\n      options[option] = props[option] = void 0;\n    }\n  });\n}\n\nvar PlainDraggable = function () {\n  /**\n   * Create a `PlainDraggable` instance.\n   * @param {Element} element - Target element.\n   * @param {Object} [options] - Options.\n   */\n  function PlainDraggable(element, options) {\n    _classCallCheck(this, PlainDraggable);\n\n    var props = {\n      ins: this,\n      options: { // Initial options (not default)\n        zIndex: ZINDEX // Initial state.\n      },\n      disabled: false\n    };\n\n    Object.defineProperty(this, '_id', { value: ++insId });\n    props._id = this._id;\n    insProps[this._id] = props;\n    props.initArguments = Array.prototype.slice.call(arguments); // [DEBUG/]\n\n    if (!isElement(element) || element === body) {\n      throw new Error('This element is not accepted.');\n    }\n    if (!options) {\n      options = {};\n    } else if (!isObject(options)) {\n      throw new Error('Invalid options.');\n    }\n\n    var gpuTrigger = true;\n    // [SVG]\n    var ownerSvg = void 0;\n    // SVGElement which is not root view\n    if (element instanceof SVGElement && (ownerSvg = element.ownerSVGElement)) {\n      // It means `instanceof SVGLocatable` (many browsers don't have SVGLocatable)\n      if (!element.getBBox) {\n        throw new Error('This element is not accepted. (SVGLocatable)');\n      }\n      // Trident and Edge bug, SVGSVGElement doesn't have SVGAnimatedTransformList?\n      if (!element.transform) {\n        throw new Error('This element is not accepted. (SVGAnimatedTransformList)');\n      }\n      // Trident bug, returned value must be used (That is not given value).\n      props.svgTransform = element.transform.baseVal.appendItem(ownerSvg.createSVGTransform());\n      props.svgPoint = ownerSvg.createSVGPoint();\n      // Gecko bug, view.getScreenCTM returns CTM with root view.\n      var svgView = element.nearestViewportElement;\n      props.svgCtmElement = !IS_GECKO ? svgView : svgView.appendChild(document.createElementNS(ownerSvg.namespaceURI, 'rect'));\n      gpuTrigger = false;\n      props.initElm = initSvg;\n      props.moveElm = moveSvg;\n    } else {\n      // [/SVG]\n      /* eslint-disable indent */ /* [SVG/] */\n      var cssPropWillChange = CSSPrefix.getName('willChange');\n      if (cssPropWillChange) {\n        gpuTrigger = false;\n      }\n\n      if (!options.leftTop && cssPropTransform) {\n        // translate\n        if (cssPropWillChange) {\n          element.style[cssPropWillChange] = 'transform';\n        }\n        props.initElm = initTranslate;\n        props.moveElm = moveTranslate;\n      } else {\n        // left and top\n        // [LEFTTOP]\n        if (cssPropWillChange) {\n          element.style[cssPropWillChange] = 'left, top';\n        }\n        props.initElm = initLeftTop;\n        props.moveElm = moveLeftTop;\n        // [/LEFTTOP]\n        /* [LEFTTOP/]\n        throw new Error('`transform` is not supported.');\n        [LEFTTOP/] */\n      }\n      /* eslint-enable indent */ /* [SVG/] */\n    } // [SVG/]\n\n    props.element = initAnim(element, gpuTrigger);\n    props.elementStyle = element.style;\n    props.orgZIndex = props.elementStyle.zIndex;\n    if (draggableClass) {\n      mClassList(element).add(draggableClass);\n    }\n    // pointerEvent new startHandler\n    props.pointerEventHandlerId = pointerEvent.regStartHandler(function (pointerXY) {\n      return dragStart(props, pointerXY);\n    });\n\n    // Default options\n    if (!options.containment) {\n      var parent = void 0;\n      options.containment = (parent = element.parentNode) && isElement(parent) ? parent : body;\n    }\n    if (!options.handle) {\n      options.handle = element;\n    }\n\n    _setOptions(props, options);\n  }\n\n  /**\n   * @param {Object} options - New options.\n   * @returns {PlainDraggable} Current instance itself.\n   */\n\n\n  _createClass(PlainDraggable, [{\n    key: 'setOptions',\n    value: function setOptions(options) {\n      if (isObject(options)) {\n        _setOptions(insProps[this._id], options);\n      }\n      return this;\n    }\n  }, {\n    key: 'position',\n    value: function position() {\n      initBBox(insProps[this._id]);\n      return this;\n    }\n  }, {\n    key: 'disabled',\n    get: function get() {\n      return insProps[this._id].disabled;\n    },\n    set: function set(value) {\n      var props = insProps[this._id];\n      if ((value = !!value) !== props.disabled) {\n        props.disabled = value;\n        if (props.disabled) {\n          if (props === activeItem) {\n            dragEnd(props);\n          }\n          props.options.handle.style.cursor = props.orgCursor;\n          if (cssPropUserSelect) {\n            props.options.handle.style[cssPropUserSelect] = props.orgUserSelect;\n          }\n          if (draggableClass) {\n            mClassList(props.element).remove(draggableClass);\n          }\n        } else {\n          setDraggableCursor(props.options.handle, props.orgCursor);\n          if (cssPropUserSelect) {\n            props.options.handle.style[cssPropUserSelect] = 'none';\n          }\n          if (draggableClass) {\n            mClassList(props.element).add(draggableClass);\n          }\n        }\n      }\n    }\n  }, {\n    key: 'element',\n    get: function get() {\n      return insProps[this._id].element;\n    }\n  }, {\n    key: 'rect',\n    get: function get() {\n      return copyTree(insProps[this._id].elementBBox);\n    }\n  }, {\n    key: 'left',\n    get: function get() {\n      return insProps[this._id].elementBBox.left;\n    },\n    set: function set(value) {\n      _setOptions(insProps[this._id], { left: value });\n    }\n  }, {\n    key: 'top',\n    get: function get() {\n      return insProps[this._id].elementBBox.top;\n    },\n    set: function set(value) {\n      _setOptions(insProps[this._id], { top: value });\n    }\n  }, {\n    key: 'containment',\n    get: function get() {\n      var props = insProps[this._id];\n      return props.containmentIsBBox ? ppBBox2OptionObject(props.options.containment) : props.options.containment;\n    },\n    set: function set(value) {\n      _setOptions(insProps[this._id], { containment: value });\n    }\n\n    // [SNAP]\n\n  }, {\n    key: 'snap',\n    get: function get() {\n      return copyTree(insProps[this._id].options.snap);\n    },\n    set: function set(value) {\n      _setOptions(insProps[this._id], { snap: value });\n    }\n    // [/SNAP]\n\n    // [AUTO-SCROLL]\n\n  }, {\n    key: 'autoScroll',\n    get: function get() {\n      return copyTree(insProps[this._id].options.autoScroll);\n    },\n    set: function set(value) {\n      _setOptions(insProps[this._id], { autoScroll: value });\n    }\n    // [/AUTO-SCROLL]\n\n  }, {\n    key: 'handle',\n    get: function get() {\n      return insProps[this._id].options.handle;\n    },\n    set: function set(value) {\n      _setOptions(insProps[this._id], { handle: value });\n    }\n  }, {\n    key: 'zIndex',\n    get: function get() {\n      return insProps[this._id].options.zIndex;\n    },\n    set: function set(value) {\n      _setOptions(insProps[this._id], { zIndex: value });\n    }\n  }, {\n    key: 'onDrag',\n    get: function get() {\n      return insProps[this._id].options.onDrag;\n    },\n    set: function set(value) {\n      _setOptions(insProps[this._id], { onDrag: value });\n    }\n  }, {\n    key: 'onMove',\n    get: function get() {\n      return insProps[this._id].options.onMove;\n    },\n    set: function set(value) {\n      _setOptions(insProps[this._id], { onMove: value });\n    }\n  }, {\n    key: 'onMoveStart',\n    get: function get() {\n      return insProps[this._id].options.onMoveStart;\n    },\n    set: function set(value) {\n      _setOptions(insProps[this._id], { onMoveStart: value });\n    }\n  }, {\n    key: 'onDragEnd',\n    get: function get() {\n      return insProps[this._id].options.onDragEnd;\n    },\n    set: function set(value) {\n      _setOptions(insProps[this._id], { onDragEnd: value });\n    }\n  }], [{\n    key: 'draggableCursor',\n    get: function get() {\n      return cssWantedValueDraggableCursor;\n    },\n    set: function set(value) {\n      if (cssWantedValueDraggableCursor !== value) {\n        cssWantedValueDraggableCursor = value;\n        cssValueDraggableCursor = null; // Reset\n        Object.keys(insProps).forEach(function (id) {\n          var props = insProps[id];\n          if (props.disabled || props === activeItem && cssValueDraggingCursor !== false) {\n            return;\n          }\n          setDraggableCursor(props.options.handle, props.orgCursor);\n          if (props === activeItem) {\n            // Since cssValueDraggingCursor is `false`, copy cursor again.\n            body.style.cursor = cssOrgValueBodyCursor;\n            body.style.cursor = window.getComputedStyle(props.options.handle, '').cursor;\n          }\n        });\n      }\n    }\n  }, {\n    key: 'draggingCursor',\n    get: function get() {\n      return cssWantedValueDraggingCursor;\n    },\n    set: function set(value) {\n      if (cssWantedValueDraggingCursor !== value) {\n        cssWantedValueDraggingCursor = value;\n        cssValueDraggingCursor = null; // Reset\n        if (activeItem) {\n          setDraggingCursor(activeItem.options.handle);\n          if (cssValueDraggingCursor === false) {\n            setDraggableCursor(activeItem.options.handle, activeItem.orgCursor); // draggableCursor\n            body.style.cursor = cssOrgValueBodyCursor;\n          }\n          body.style.cursor = cssValueDraggingCursor || // If it is `false` or `''`\n          window.getComputedStyle(activeItem.options.handle, '').cursor;\n        }\n      }\n    }\n  }, {\n    key: 'draggableClass',\n    get: function get() {\n      return draggableClass;\n    },\n    set: function set(value) {\n      value = value ? value + '' : void 0;\n      if (value !== draggableClass) {\n        Object.keys(insProps).forEach(function (id) {\n          var props = insProps[id];\n          if (!props.disabled) {\n            var classList = mClassList(props.element);\n            if (draggableClass) {\n              classList.remove(draggableClass);\n            }\n            if (value) {\n              classList.add(value);\n            }\n          }\n        });\n        draggableClass = value;\n      }\n    }\n  }, {\n    key: 'draggingClass',\n    get: function get() {\n      return draggingClass;\n    },\n    set: function set(value) {\n      value = value ? value + '' : void 0;\n      if (value !== draggingClass) {\n        if (activeItem) {\n          var classList = mClassList(activeItem.element);\n          if (draggingClass) {\n            classList.remove(draggingClass);\n          }\n          if (value) {\n            classList.add(value);\n          }\n        }\n        draggingClass = value;\n      }\n    }\n  }, {\n    key: 'movingClass',\n    get: function get() {\n      return movingClass;\n    },\n    set: function set(value) {\n      value = value ? value + '' : void 0;\n      if (value !== movingClass) {\n        if (activeItem && hasMoved) {\n          var classList = mClassList(activeItem.element);\n          if (movingClass) {\n            classList.remove(movingClass);\n          }\n          if (value) {\n            classList.add(value);\n          }\n        }\n        movingClass = value;\n      }\n    }\n  }]);\n\n  return PlainDraggable;\n}();\n\n// pointerEvent add moveHandler\n\n\npointerEvent.addMoveHandler(document, function (pointerXY) {\n  if (activeItem && move(activeItem, {\n    left: pointerXY.clientX + window.pageXOffset + pointerOffset.left,\n    top: pointerXY.clientY + window.pageYOffset + pointerOffset.top\n  },\n  // [SNAP]\n  activeItem.snapTargets ? function (position) {\n    // Snap\n    var iLen = activeItem.snapTargets.length;\n    var snappedX = false,\n        snappedY = false,\n        i = void 0;\n    for (i = 0; i < iLen && (!snappedX || !snappedY); i++) {\n      var snapTarget = activeItem.snapTargets[i];\n      if ((snapTarget.gravityXStart == null || position.left >= snapTarget.gravityXStart) && (snapTarget.gravityXEnd == null || position.left <= snapTarget.gravityXEnd) && (snapTarget.gravityYStart == null || position.top >= snapTarget.gravityYStart) && (snapTarget.gravityYEnd == null || position.top <= snapTarget.gravityYEnd)) {\n        if (!snappedX && snapTarget.x != null) {\n          position.left = snapTarget.x;\n          snappedX = true;\n          i = -1; // Restart loop\n        }\n        if (!snappedY && snapTarget.y != null) {\n          position.top = snapTarget.y;\n          snappedY = true;\n          i = -1; // Restart loop\n        }\n      }\n    }\n    position.snapped = snappedX || snappedY;\n    return activeItem.onDrag ? activeItem.onDrag(position) : true;\n  } :\n  // [/SNAP]\n  activeItem.onDrag)) {\n\n    // [AUTO-SCROLL]\n    var xyMoveArgs = {},\n        autoScroll = activeItem.autoScroll;\n    if (autoScroll) {\n      var clientXY = {\n        x: activeItem.elementBBox.left - window.pageXOffset,\n        y: activeItem.elementBBox.top - window.pageYOffset\n      };\n\n      ['x', 'y'].forEach(function (axis) {\n        if (autoScroll[axis]) {\n          var min = autoScroll[axis].min,\n              max = autoScroll[axis].max;\n          autoScroll[axis].lines.some(function (line) {\n            if (line.dir === -1 ? clientXY[axis] <= line.position : clientXY[axis] >= line.position) {\n              xyMoveArgs[axis] = { dir: line.dir, speed: line.speed / 1000, min: min, max: max };\n              return true;\n            }\n            return false;\n          });\n        }\n      });\n    }\n    if (xyMoveArgs.x || xyMoveArgs.y) {\n      scrollFrame.move(autoScroll.target, xyMoveArgs, autoScroll.isWindow ? scrollXYWindow : scrollXYElement);\n    } else {\n      scrollFrame.stop();\n    }\n    // [/AUTO-SCROLL]\n\n    if (!hasMoved) {\n      hasMoved = true;\n      if (movingClass) {\n        mClassList(activeItem.element).add(movingClass);\n      }\n      if (activeItem.onMoveStart) {\n        activeItem.onMoveStart();\n      }\n    }\n    if (activeItem.onMove) {\n      activeItem.onMove();\n    }\n  }\n});\n\n// pointerEvent add endHandler\npointerEvent.addEndHandler(document, function () {\n  if (activeItem) {\n    dragEnd(activeItem);\n  }\n});\n\n{\n  var initDoc = function initDoc() {\n    cssPropTransitionProperty = CSSPrefix.getName('transitionProperty');\n    cssPropTransform = CSSPrefix.getName('transform');\n    cssOrgValueBodyCursor = body.style.cursor;\n    if (cssPropUserSelect = CSSPrefix.getName('userSelect')) {\n      cssOrgValueBodyUserSelect = body.style[cssPropUserSelect];\n    }\n\n    // Init active item when layout is changed, and init others later.\n\n    var LAZY_INIT_DELAY = 200;\n    var initDoneItems = {},\n        lazyInitTimer = void 0;\n\n    function checkInitBBox(props, eventType) {\n      if (props.initElm) {\n        // Easy checking for instance without errors.\n        initBBox(props, eventType);\n      } // eslint-disable-line brace-style\n      else {\n          console.log('instance may have an error:');console.log(props);\n        } // [DEBUG/]\n    }\n\n    function initAll(eventType) {\n      clearTimeout(lazyInitTimer);\n      Object.keys(insProps).forEach(function (id) {\n        if (!initDoneItems[id]) {\n          checkInitBBox(insProps[id], eventType);\n        }\n      });\n      initDoneItems = {};\n    }\n\n    var layoutChanging = false; // Gecko bug, multiple calling by `resize`.\n    var layoutChange = AnimEvent.add(function (event) {\n      if (layoutChanging) {\n        console.log('`resize/scroll` event listener is already running.'); // [DEBUG/]\n        return;\n      }\n      layoutChanging = true;\n\n      if (activeItem) {\n        checkInitBBox(activeItem, event.type);\n        pointerEvent.callMoveHandler();\n        initDoneItems[activeItem._id] = true;\n      }\n      clearTimeout(lazyInitTimer);\n      lazyInitTimer = setTimeout(function () {\n        initAll(event.type);\n      }, LAZY_INIT_DELAY);\n\n      layoutChanging = false;\n    });\n    window.addEventListener('resize', layoutChange, true);\n    window.addEventListener('scroll', layoutChange, true);\n  };\n\n  if (body = document.body) {\n    initDoc();\n  } else {\n    document.addEventListener('DOMContentLoaded', function () {\n      body = document.body;\n      initDoc();\n    }, false);\n  }\n}\n\n/* [SNAP/]\nPlainDraggable.limit = true;\n[SNAP/] */\n\nexport default PlainDraggable;"],"sourceRoot":""}